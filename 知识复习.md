# 知识复习

## HTML

### html 元素的分类和特性

- html 常见元素和理解
- html版本
- html 元素分类
- html元素嵌套关系
- html 元素默认样式和定制化
- 面试题

#### html 常见元素和理解

**html 常见元素**

head中

meta、title、style、link、script、base

```html
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

body中

- div/section/article/aside/header/footer
- p
- span/em/strong
- table/thead/tbody/tr/td
- a
- form/input/select/textarea/button

**html 重要属性**

```css
a[href, target]
img[src alt]
table td[colspan, rowspan]
form[target, method, enctype]
input[type, value]
button[type]
select>option[value]
label[for]
```

#### 如何理解 html 语义化

有利于搜索引擎搜索，便于开发人员阅读

#### html5新增内容

html5中和html相关的内容

- 新区块标签：section/article、nav、aside、header/footer、em/strong、i （icon）
- 表单增强：日期时间搜索、表单验证、placeholder自动聚焦

#### html 元素分类

- 按默认样式分：块级 block、行内 inline、inline-block
- 按内容分：。。。。。。

#### html 元素嵌套关系

- 块级元素可以包含行内元素
- 块级元素不一定能包含块级元素
- 行内元素一般不能包含块级元素（除 a>div是合法的）

### html 元素默认样式和定制化

默认样式的意义：快捷方便。

默认样式带来的问题：不是我们需要的。可以通过 css reset或直接 * {margin: 0; padding: 0;} 或 normalize.css。

### html 面试真题

#### doctype 的意义是什么

- 让浏览器以标准模式渲染
- 让浏览器知道元素的合法性

#### HTML XHTML HTML5的关系

- HTML 属于 SGML
- SHTML 属于 XML，是 HTML 进行 XML 严格化的结果
- HTML5 不属于 SGML 或 SML，比 XHTML 宽松

#### HTML5 有什么变化

- 新的语义化元素
- 分类和嵌套变更
- 表单增强
- 新的API(离线、音视频、图形、实时通信、本地存储、设备能力)

#### em 和 i 有什么区别

- em是语义化的标签，表强调
- i 是纯样式的标签，表斜体
- HTML5中 i 不推荐使用，一般用作图标

#### 语义化的意义是什么

- 开发者容易理解
- 机器容易理解结构（搜索、读屏、软件）
- 有助于 SEO
- semantic microdata

#### 哪些元素可以自闭合

- 表单元素 input
- 图片 img
- br hr
- meta link

#### html 和 dom 的关系

- html 是 “死”的
- dom 由 html 解析而来，是活的
- js 可以维护 dom

#### property 和 attribute 的区别

- attribute 是 “死”的
- property 是“活”的

#### form的作用有哪些

- 直接提交表单
- 使用 submit / reset 按钮
- 便于浏览器保存表单
- 第三方库可以整体提取值
- 第三方库可以进行表单验证

## css

### css选择器

选择器

- 用于匹配HTML元素
- 分类和权重
- 解析方式和性能
- 值得关注的选择器

浏览器的解析方式：从右往左（节省性能）

```css
.body div .hello {
  color: red;
}
```

####  选择器分类

- 元素选择器 a {}
- 伪元素选择器 ::before {}
- 类选择器 .link {}
- 属性选择器 [type=radio] {}
- 伪类选择器 :hover {}
- ID选择器 #id {}
- 组合选择器 [type=checkbox] + label {}
- 否定选择器 :not(.link) {}
- 通用选择器 * {}

 #### 选择器权重

- ID选择器 #id{} +100
- 类 属性 伪类 +10
- 元素 伪元素 +1
- 其他选择器 +0
- !important 优先级最高
- 元素属性(行内属性) 优先级高
- 相同权重 后写的生效

> 不进位，官大一级压死人

### css常见属性 

- 字体、字重、颜色、大小、行高
- 背景、边框
- 滚动、换行
- 粗体、斜体、下划线
- 其他

#### 非布局样式(字体)

- 字体族：serif sans-serif monospace cursive fantasy
- 多字体fallback
- 网络字体、自定义字体
- iconfont

> 多平台字体适配 ->fallback机制
>
> iconfont原理 -> 自定义机制

#### 非布局样式(行高)

- 行高的构成
- 行高相关的现象和方案
- 行高的调整

> 图片下面有空隙原理是什么？如何去除？
>
> 图片样式按照内联元素进行对齐的，也要遵守行高的构成，默认是按照 base-line 方式对齐，base-line 与底线之间是有偏差的，偏差大小视字体大小而定，例如字体12px，偏差大约为3px(经典的3px缝隙问题)
>
> 解决方式：
>
> 1.更换字体排列方式 vertical-align: bottom; 按底线对齐
>
> 2.让img变为block元素 display: block;

#### 非布局样式(背景)

- 背景颜色
- 渐变色背景
- 多背景叠加
- 背景图片和属性(雪碧图)
- base64 和性能优化
- 多分辨率适配

```css
/* 背景颜色 渐变色背景 多背景叠加 */
body{
  background:yellow;
}
.c1{
  height:90px;
  /* background:rgba(255,0,0, .3); */
  /* background:url(./test.png); */
}
.c2{
  height:90px;
  /* background: -webkit-linear-gradient(left, red, green); */
  /* background: linear-gradient(to right, red, green); */
  /* background: linear-gradient(180deg, red, green); */
  /* background: linear-gradient(135deg, red 0, green 10%, yellow 50%, blue 100%); */
  background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%),
    linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%);
  background-size: 30px 30px;
}
```
> 性能提升：雪碧图(减少http请求)、base64(减少http请求，但本身体积增大1/3，增大了解码要求，只用于小图标)
>
> 多分辨率适配：通过设置成比例背景图的width、height、background-position、backround-size

```css
.c1{
  height:900px;
  background:red url(data:image/png;base64,...)
    background-repeat: no-repeat;
  /* background-position: center top; */
  /* background-position: 20px 30px; */
  /* background-size:100px 50px; */
}
.c2{
  width:20px;
  height:20px;
  background:url(./test_bg.png) no-repeat;
  background-position: -17px -5px;
  background-size: 261px 113px;
}
.c3{
  width:20px;
  height:20px;
  background:url(./test_bg.png) no-repeat;
  background-position: -169px -23px;
  background-size: 261px 113px;
}
```

#### 非布局样式(背景)

- 边框的属性： 线型 大小 颜色
- 边框背景图
- 边框衔接(三角形)

#### 非布局样式(滚动)

- 滚动行为和滚动条

![1571811980532](./img/css-非布局样式-滚动.png)

#### 非布局样式(文字折行)

- overflow-wrap(word-wrap) 通用换行控制
  - 是否保留单词
- word-break 针对多字节文字
  - 中文句子也是单词
- white-space 空白处是否断行

> 不换行，white-wrap:nowrap

#### 非布局样式(装饰性属性及其它)

- 字重(粗体) font-weight
- 斜体 font-style: itatic
- 下划线 text-decoration
- 指针 cursor

### css 面试题

#### css样式(选择器)的优先级

- 计算权重确定
- !important
- 内联样式
- 后写的优先级高

#### 雪碧图的作用

- 减少HTTP请求数 提高加载性能
- 有一些情况下可以减少图片大小

#### 自定义字体的使用场景

- 宣传/品牌/banner等固定文案
- 字体图标

#### base64的使用

- 用于减少HTTP请求
- 适用于小图片
- base64的体积约为原图4/3

#### 伪类和伪元素的区别

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号

#### 如何美化checkbox

- label[for]和id
- 隐藏原生input
- :checked + label

### css布局

- 早期以table为主(简单)
- 后来以技巧性布局为主(难)
- 现在有flexbox/grid（偏简单）
- 响应式布局是必备知识

常用布局方法

- table 表格布局
- float 浮动 + margin
- inline-block 布局
- flexbox 布局

#### 盒子模型
![1571814106768](./img/css-布局-盒模型.png)

**display / position**

- 确定元素的显示类型
  - block/inline/inline-block
- 确定元素的位置
  - static/relative/absolute/fixed

#### table 布局

左右布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .left{
            background:red;
        }
        .right{
            background:blue;
        }
        table{
            width:800px;
            height:200px;
            border-collapse: collapse;
        }
        .table{
            margin-top:20px;
            display: table;
            width:800px;
            height:200px;
        }
        .table-row{
            display: table-row;
            text-align: center;
        }
        .table-cell{
            vertical-align: middle;
            display: table-cell;
        }
    </style>
</head>
<body>
    <table>
        <tr>
            <td class="left">左</td>
            <td class="right">右</td>
        </tr>
    </table>
    <div class="table">
        <div class="table-row">
            <div class="left table-cell">
                左
            </div>
            <div class="right table-cell">
                右
            </div>
        </div>
    </div>
</body>
</html>
```

#### flexbox布局

- 弹性盒子
- 盒子本来就是并列的
- 指定宽度即可

#### float 布局

- 元素”浮动“
- 脱离文档流
- 但不脱离文本流

**float特性**

- 形成“块”(BFC)，可以设置宽高
- 位置尽量靠上
- 位置尽量靠左(右)

**对兄弟的影响**

- 上面贴非float元素
- 旁边贴float元素
- 不影响其它块级元素位置
- 影响其它块级元素内部文本

**对父级元素的影响**

- 从布局上“消失”

- 高度塌陷

  - 1.父元素，overflow:auto;

  - 2.给父元素添加伪元素撑起高度

    - ```css
      .father::after {
      	content: '';
        clear:both;
        display:block;
        visibility: hidden;
        height: 0;
      }
      ```

```html
float 用于图文混排，脱离文档流，但不脱离文本流
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container{
            background:red;
            width:400px;
            margin:20px;
        }
        .p1{
            background:green;
            float:left;
            width:200px;
            height:50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <span class="p1">
            float
        </span>
        <div class="p2">
            很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字
        </div>
    </div>
</body>
</html>
```

**float三栏布局**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container{
            width:800px;
            height:200px;
        }
        .left{
            background:red;
            /* float:left; */
            /* height:100%; */
            width:200px;
            height:200px;
        }
        .right{
            background:blue;
            float:right;
            width:200px;
            height:100%;
        }
        .middle{
            margin-left:200px;
            margin-right:200px;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="left">
            左
        </div>
        <div class="right">
            右
        </div>
        <div class="middle">
            中间
        </div>
    </div>
</body>
</html>
```

#### inline-block 布局

- 像文本一样排block元素
- 没有清除浮动等问题
- 需要处理间隙（inline-block块相当于文字，文字是有间隙的）
  - 设置父元素字体为0，再设置子元素字体大小
  - 空隙来源是html的空白，1.可以去掉空白，紧挨着。2.或者通过注释的方式

#### 响应式设计与布局

- 在不同设备上正常使用
- 一般主要处理屏幕大小问题
- 主要方法：
  - 隐藏 + 折行 + 自适应空间
  - rem / viewport / media query

### 动画与效果 

- 多背景多投影特效
- 3d特效编写实践
- 过渡动画和关键帧动画实践
- 动画细节和原理深入解析

#### 效果属性

- box-shadow
- text-shadow
- border-radius
- background
- clip-path
  - 对容器进行裁剪（和border-radius相比，它位置不变，适合做动画）
  - 常见几何图形
  - 自定义路径

box-shadow

```css
.some {
  Box-shadow: xpx ypx 模糊区域px 扩展px rgba;
  Box-shadow: xpx ypx 模糊区域px 扩展px rgba inset;
}
```



### 框架集成和css工程化

- 预处理器作用和原理
- less/sass代码实践
- bootstrap原理和用法
- css工程化实践方式
- js框架中的css集成实践

### 超出滚动

水平方向滚动：`overflow: hidden; overflow-x: scroll;`

垂直方向滚动：`overflow: hidden; overflow-y: auto;

移动端页面超出滚动：

 ```css
.home {
  width: 100%;
  height: 100%;
  overflow: hidden;
  overflow-y: auto;
}
 ```

### 内容省略

```css
// 文本最多两行展示
.text-line-2 {
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-word;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  display: -webkit-box;
}
```

### 对齐方式

垂直居中 height === line-height、padding-top === padding-left、父display:flex;子align-self:center;

水平居中 margin: 0 auto;

### 生成三角形

```css
// 三角形
.caret {
  display: inline-block;
  width: 0;
  height: 0;
  border-top: px2rem(8) solid $mainColor;
  border-left: px2rem(6) solid transparent;
  border-right: px2rem(6) solid transparent;
}
```



## js

几道面试题

- js 中使用 typeof 能得到的哪些类型  （js 变量类型）
- 何时使用 === 何时使用 == （强制类型转换）
- window.onload 和 DOMContentLoaded 的区别 （浏览器渲染过程）
- 用 JS 创建 10 个 `<a>`标签，点击的时候弹出对应的序号 （作用域）
- 简述如何实现一个模块加载器，实现类似 require.js 的基本功能 （js 模块化）
- 实现数组的随机排序 （js基础算法）

### js基础

- 原型 原型链
- 作用域 闭包
- 异步 单线程

#### 变量类型与计算

- 变量类型：值类型、引用类型（对象、数组、函数）
- 变量计算

**强制类型转换**

- 字符串拼接

  - ```js
    var a = 100 + 10 // 110
    var b = 100 + '10' // '10010'
    ```

- == 运算符

  - ```js
    100 == '100' // true
    0 == '' // true
    null == undefined // true
    ```

- if 语句

  - ```js
    var a = true;if (a) {};
    var b = 100; if (b) {};
    var c = ''; if (c) {};
    ```

- 逻辑运算

  - ```js
    console.log(10 && 0) // 0
    console.log('' || 'abc') // 'abc'
    console.log(!window.abc) // true
    // 判断一个变量会被当成 true 还是 false
    var a = 100
    console.log(!!a)
    ```

#### 面试题

- js 中使用 typeof 能得到哪些类型
- 何时使用 === 何时使用 == 
- js 中有哪些内置函数
- js 变量按照存储方式区分为哪些类型，并描述其特点
- 如何理解 JSON

##### js 中使用 typeof 能得到哪些类型

```js
typeof undefined // undefined
typeof 'abc' // string
typeof 123 // number
typeof true // boolean
typeof {} // object
typeof [] // object
typeof null // object
typeof console.log // function
```

##### 何时使用 === 何时使用 ==

除了下面这种全部用 ===

```js
if (obj.a == null) {
	// 这里相当于 obj.a === null || obj.a === undefined，简写形式
  // 这里是 jquery 源码中推荐的写法
}
```

##### JS中有哪些内置函数 __ 数据封装类对象

Object、Array、Function、Boolean、Number、String、Date、RegExp、Error

##### JS按存储方式区分变量类型

值类型、引用类型

##### 如何理解JSON

JSON 只不过是一个 JS 对象而已

```js
JSON.stringify({a:10, b:20})
JSON.parse('{"a": 10, "b": 20}')
```

#### 原型和原型链

- 构造函数
- 构造函数 - 扩展
- 原型规则和示例
- 原型链
- instanceof

**构造函数**

```js
function Foo(name, age) {
  this.name = name
  this.age = age
  this.class = 'class-1'
  // return this // 默认有这一行
}
var f = new Foo('zhangsan', 20)
```

**构造函数 - 扩展**

- var a = {}  其实是 var a = new Object() 的语法糖
- var a = [] 其实是 var a = new Array() 的语法糖
- function Foo() {...} 其实是 var Foo = new Function(...)
- 使用 instanceof 判断一个变量是否是一个数组的构造函数 -> instanceof Array

**原型规则和示例**

5条原型规则（原型链的基础）

- 所有的引用类型(数组、对象、函数)，都具有对象特性，即可自由扩展属性（除了“null”以外）。
- 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象。
- 所有的函数，都有一个 prototype 属性，属性值也是一个普通的对象。
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的“prototype”属性值。
- 当试图得到一个对象的某个属性时，如果这个对象本身本身没有这个属性，那么会去它的`__proto__`（即它的构造函数的 prototype）中寻找。

```js
// 前 4 条规则
var obj = {}; obj.a = 100;
var arr = []; arr.a = 100;
function fn () {}
fn.a = 100;

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

console.log(obj.__proto__ === Object.prototype)
// 第 5 条规则
function Foo(name, age) {
  this.name = name
}
Foo.prototype.alertName = function() {
  alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function() {
  console.log(this.name)
}
// 测试
f.printName()
f.alerName()
```

循环对象自身的属性

```js
var item
for (item in f) {
  // 高级浏览器已经在 for in 中屏蔽了来自原型的属性
  // 但这里还是建议加上这个判断，保证程序的健壮性
  if (f.hasOwnProperty(item)) {
    console.log(item)
	}
}
```

**原型链**

```js
// 构造函数
function Foo(name, age) {
  this.name = name
}
Foo.prototype.alertName = function () {
  alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function () {
  console.log(this.name)
}
// 测试
f.printName()
f.alertName()
f.toString() // 要去 f.__proto__.__proto__中查找
```

![1571907714695](./img/js-原型链-示例.png)

**instanceof**

用于判断**引用类型**属性哪个**构造函数**的方案，原理也是基于原型链向上查找规则。

#### 面试题

##### 如何准确判断一个变量是数组类型

```js
var arr = []
arr instanceof Array // true
```

##### 写一个原型链继承的例子

简单的例子（**面试减分。。。**）

```js
// 动物
function Animal() {
  this.eat = function() {
    console.log('animal eat')
  }
}
// 狗
function Dog() {
  this.bark = function() {
    console.log('dog bark')
  }
}
Dog.prototype = new Animal()
// 哈士奇
var hashqi = new Dog()
```

实用的例子 -- 封装DOM查询

```js
function Elem(id) {
  this.elem = document.getElementById(id)
}

Elem.prototype.html = function (val) {
  var elem = this.elem
  if (val) {
    elem.innerHTML = val
    return this // 链式操作
  } else {
    return elem.innerHTML
  }
}

Elem.prototype.on = function ()


var div1 = new Elem('div1')
```



##### 描述 new 一个对象的过程

- 创建一个对象
- this 指向这个对象
- 执行代码，即对 this 赋值
- 返回 this

```js
function Foo(name, age) {
  this.name = name
  this.age = age
  this.class = 'class-1'
  // return this // 默认有这一行
}
var f = new Foo('zhangsan', 20)
```

##### zepto (或其他框架) 源码中如何使用原型链

- 慕课 “zepto设计和源码分析”

### js-web-api

- dom操作
- ajax
- 事件绑定

### js开发环境

- 版本管理
- 模块化
- 打包工具

### 运行环境

- 页面渲染
- 性能优化
- 安全



### 数字相关

获取随机整数区间

```js
function getNumberIn(start, end) {
	return Math.floor(Math.random() * (end- start) + start)
}
```

### dom操作

获取元素的高度

```js
$le.clientHeight
```

页面滚动距离

监听页面根元素的 scroll 事件，通过 event.target.scrollTop

## vue

### nextTick

涉及到 dom 渲染相关操作时，注意可能需要使用 nextTick

```vue
this.$nextTick(() => {
	// code
})
```

### vue性能优化

路由懒加载、组件懒加载

懒加载

路由组件的懒加载

```js
// router.js
{
    path: '/goodsList',
    name: 'goodsList',
    // vue-router 懒加载 -> GoodsList
    component: () => import(/* webpackChunkName: "about" */ '../views/GoodsList.vue')
  }
```

组件的懒加载

```vue
// Main.vue
components: {
    ToolBar,
    // 异步组件引入方式, 异步组件：只有在需要去展示这个组件的时候，才会把组件去进行渲染。
    home: () => import('@c/Home'),
    shopping: () => import('@c/Shopping'),
    my: () => import('@c/My')
  },
```





## 业务相关

### 瀑布流

瀑布流的布局：

​      1、创建商品列表的基本html 和 css ， 让 item 相对于 goods（div）进行排列(相对布局)

​      2、生成不同高度的图片，撑起不同高度的 item。

​      3、计算 item 的位置，来达到 从上到下，从左到右依次排列的目的

