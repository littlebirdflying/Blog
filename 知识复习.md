- 知识复习

## HTML

### html 元素的分类和特性

- html 常见元素和理解
- html版本
- html 元素分类
- html元素嵌套关系
- html 元素默认样式和定制化
- 面试题

#### html 常见元素和理解

**html 常见元素**

head中

meta、title、style、link、script、base

```html
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

body中

- div/section/article/aside/header/footer
- p
- span/em/strong
- table/thead/tbody/tr/td
- a
- form/input/select/textarea/button

**html 重要属性**

```css
a[href, target]
img[src alt]
table td[colspan, rowspan]
form[target, method, enctype]
input[type, value]
button[type]
select>option[value]
label[for]
```

#### 如何理解 html 语义化

有利于搜索引擎搜索，便于开发人员阅读

#### html5新增内容

html5中和html相关的内容

- 新区块标签：section/article、nav、aside、header/footer、em/strong、i （icon）
- 表单增强：日期时间搜索、表单验证、placeholder自动聚焦

#### html 元素分类

- 按默认样式分：块级 block、行内 inline、inline-block
- 按内容分：。。。。。。

#### html 元素嵌套关系

- 块级元素可以包含行内元素
- 块级元素不一定能包含块级元素
- 行内元素一般不能包含块级元素（除 a>div是合法的）

### html 元素默认样式和定制化

默认样式的意义：快捷方便。

默认样式带来的问题：不是我们需要的。可以通过 css reset或直接 * {margin: 0; padding: 0;} 或 normalize.css。

### html 面试真题

#### doctype 的意义是什么

- 让浏览器以标准模式渲染
- 让浏览器知道元素的合法性

#### HTML XHTML HTML5的关系

- HTML 属于 SGML
- SHTML 属于 XML，是 HTML 进行 XML 严格化的结果
- HTML5 不属于 SGML 或 SML，比 XHTML 宽松

#### HTML5 有什么变化

- 新的语义化元素
- 分类和嵌套变更
- 表单增强
- 新的API(离线、音视频、图形、实时通信、本地存储、设备能力)

#### em 和 i 有什么区别

- em是语义化的标签，表强调
- i 是纯样式的标签，表斜体
- HTML5中 i 不推荐使用，一般用作图标

#### 语义化的意义是什么

- 开发者容易理解
- 机器容易理解结构（搜索、读屏、软件）
- 有助于 SEO
- semantic microdata

#### 哪些元素可以自闭合

- 表单元素 input
- 图片 img
- br hr
- meta link

#### html 和 dom 的关系

- html 是 “死”的
- dom 由 html 解析而来，是活的
- js 可以维护 dom

#### property 和 attribute 的区别

- attribute 是 “死”的
- property 是“活”的

#### form的作用有哪些

- 直接提交表单
- 使用 submit / reset 按钮
- 便于浏览器保存表单
- 第三方库可以整体提取值
- 第三方库可以进行表单验证

## css

### css选择器

选择器

- 用于匹配HTML元素
- 分类和权重
- 解析方式和性能
- 值得关注的选择器

浏览器的解析方式：从右往左（节省性能）

```css
.body div .hello {
  color: red;
}
```

####  选择器分类

- 元素选择器 a {}
- 伪元素选择器 ::before {}
- 类选择器 .link {}
- 属性选择器 [type=radio] {}
- 伪类选择器 :hover {}
- ID选择器 #id {}
- 组合选择器 [type=checkbox] + label {}
- 否定选择器 :not(.link) {}
- 通用选择器 * {}

 #### 选择器权重

- ID选择器 #id{} +100
- 类 属性 伪类 +10
- 元素 伪元素 +1
- 其他选择器 +0
- !important 优先级最高
- 元素属性(行内属性) 优先级高
- 相同权重 后写的生效

> 不进位，官大一级压死人

### css常见属性 

- 字体、字重、颜色、大小、行高
- 背景、边框
- 滚动、换行
- 粗体、斜体、下划线
- 其他

#### 非布局样式(字体)

- 字体族：serif sans-serif monospace cursive fantasy
- 多字体fallback
- 网络字体、自定义字体
- iconfont

> 多平台字体适配 ->fallback机制
>
> iconfont原理 -> 自定义机制

#### 非布局样式(行高)

- 行高的构成
- 行高相关的现象和方案
- 行高的调整

> 图片下面有空隙原理是什么？如何去除？
>
> 图片样式按照内联元素进行对齐的，也要遵守行高的构成，默认是按照 base-line 方式对齐，base-line 与底线之间是有偏差的，偏差大小视字体大小而定，例如字体12px，偏差大约为3px(经典的3px缝隙问题)
>
> 解决方式：
>
> 1.更换字体排列方式 vertical-align: bottom; 按底线对齐
>
> 2.让img变为block元素 display: block;

#### 非布局样式(背景)

- 背景颜色
- 渐变色背景
- 多背景叠加
- 背景图片和属性(雪碧图)
- base64 和性能优化
- 多分辨率适配

```css
/* 背景颜色 渐变色背景 多背景叠加 */
body{
  background:yellow;
}
.c1{
  height:90px;
  /* background:rgba(255,0,0, .3); */
  /* background:url(./test.png); */
}
.c2{
  height:90px;
  /* background: -webkit-linear-gradient(left, red, green); */
  /* background: linear-gradient(to right, red, green); */
  /* background: linear-gradient(180deg, red, green); */
  /* background: linear-gradient(135deg, red 0, green 10%, yellow 50%, blue 100%); */
  background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%),
    linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%);
  background-size: 30px 30px;
}
```
> 性能提升：雪碧图(减少http请求)、base64(减少http请求，但本身体积增大1/3，增大了解码要求，只用于小图标)
>
> 多分辨率适配：通过设置成比例背景图的width、height、background-position、backround-size

```css
.c1{
  height:900px;
  background:red url(data:image/png;base64,...)
    background-repeat: no-repeat;
  /* background-position: center top; */
  /* background-position: 20px 30px; */
  /* background-size:100px 50px; */
}
.c2{
  width:20px;
  height:20px;
  background:url(./test_bg.png) no-repeat;
  background-position: -17px -5px;
  background-size: 261px 113px;
}
.c3{
  width:20px;
  height:20px;
  background:url(./test_bg.png) no-repeat;
  background-position: -169px -23px;
  background-size: 261px 113px;
}
```

#### 非布局样式(背景)

- 边框的属性： 线型 大小 颜色
- 边框背景图
- 边框衔接(三角形)

#### 非布局样式(滚动)

- 滚动行为和滚动条

![1571811980532](./img/css-非布局样式-滚动.png)

#### 非布局样式(文字折行)

- overflow-wrap(word-wrap) 通用换行控制
  - 是否保留单词
- word-break 针对多字节文字
  - 中文句子也是单词
- white-space 空白处是否断行

> 不换行，white-wrap:nowrap

#### 非布局样式(装饰性属性及其它)

- 字重(粗体) font-weight
- 斜体 font-style: itatic
- 下划线 text-decoration
- 指针 cursor

### css 面试题

#### css样式(选择器)的优先级

- 计算权重确定
- !important
- 内联样式
- 后写的优先级高

#### 雪碧图的作用

- 减少HTTP请求数 提高加载性能
- 有一些情况下可以减少图片大小

#### 自定义字体的使用场景

- 宣传/品牌/banner等固定文案
- 字体图标

#### base64的使用

- 用于减少HTTP请求
- 适用于小图片
- base64的体积约为原图4/3

#### 伪类和伪元素的区别

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号

#### 如何美化checkbox

- label[for]和id
- 隐藏原生input
- :checked + label

### css布局

- 早期以table为主(简单)
- 后来以技巧性布局为主(难)
- 现在有flexbox/grid（偏简单）
- 响应式布局是必备知识

常用布局方法

- table 表格布局
- float 浮动 + margin
- inline-block 布局
- flexbox 布局

#### 盒子模型
![1571814106768](./img/css-布局-盒模型.png)

**display / position**

- 确定元素的显示类型
  - block/inline/inline-block
- 确定元素的位置
  - static/relative/absolute/fixed

#### table 布局

左右布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .left{
            background:red;
        }
        .right{
            background:blue;
        }
        table{
            width:800px;
            height:200px;
            border-collapse: collapse;
        }
        .table{
            margin-top:20px;
            display: table;
            width:800px;
            height:200px;
        }
        .table-row{
            display: table-row;
            text-align: center;
        }
        .table-cell{
            vertical-align: middle;
            display: table-cell;
        }
    </style>
</head>
<body>
    <table>
        <tr>
            <td class="left">左</td>
            <td class="right">右</td>
        </tr>
    </table>
    <div class="table">
        <div class="table-row">
            <div class="left table-cell">
                左
            </div>
            <div class="right table-cell">
                右
            </div>
        </div>
    </div>
</body>
</html>
```

#### flexbox布局

- 弹性盒子
- 盒子本来就是并列的
- 指定宽度即可

#### float 布局

- 元素”浮动“
- 脱离文档流
- 但不脱离文本流

**float特性**

- 形成“块”(BFC)，可以设置宽高
- 位置尽量靠上
- 位置尽量靠左(右)

**对兄弟的影响**

- 上面贴非float元素
- 旁边贴float元素
- 不影响其它块级元素位置
- 影响其它块级元素内部文本

**对父级元素的影响**

- 从布局上“消失”

- 高度塌陷

  - 1.父元素，overflow:auto;

  - 2.给父元素添加伪元素撑起高度

    - ```css
      .father::after {
      	content: '';
        clear:both;
        display:block;
        visibility: hidden;
        height: 0;
      }
      ```

```html
float 用于图文混排，脱离文档流，但不脱离文本流
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container{
            background:red;
            width:400px;
            margin:20px;
        }
        .p1{
            background:green;
            float:left;
            width:200px;
            height:50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <span class="p1">
            float
        </span>
        <div class="p2">
            很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字
        </div>
    </div>
</body>
</html>
```

**float三栏布局**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container{
            width:800px;
            height:200px;
        }
        .left{
            background:red;
            /* float:left; */
            /* height:100%; */
            width:200px;
            height:200px;
        }
        .right{
            background:blue;
            float:right;
            width:200px;
            height:100%;
        }
        .middle{
            margin-left:200px;
            margin-right:200px;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="left">
            左
        </div>
        <div class="right">
            右
        </div>
        <div class="middle">
            中间
        </div>
    </div>
</body>
</html>
```

#### inline-block 布局

- 像文本一样排block元素
- 没有清除浮动等问题
- 需要处理间隙（inline-block块相当于文字，文字是有间隙的）
  - 设置父元素字体为0，再设置子元素字体大小
  - 空隙来源是html的空白，1.可以去掉空白，紧挨着。2.或者通过注释的方式

#### 响应式设计与布局

- 在不同设备上正常使用
- 一般主要处理屏幕大小问题
- 主要方法：
  - 隐藏 + 折行 + 自适应空间
  - rem / viewport / media query

### 动画与效果 

- 多背景多投影特效
- 3d特效编写实践
- 过渡动画和关键帧动画实践
- 动画细节和原理深入解析

#### 效果属性

- box-shadow
- text-shadow
- border-radius
- background
- clip-path
  - 对容器进行裁剪（和border-radius相比，它位置不变，适合做动画）
  - 常见几何图形
  - 自定义路径

box-shadow

```css
.some {
  Box-shadow: xpx ypx 模糊区域px 扩展px rgba;
  Box-shadow: xpx ypx 模糊区域px 扩展px rgba inset;
}
```



### 框架集成和css工程化

- 预处理器作用和原理
- less/sass代码实践
- bootstrap原理和用法
- css工程化实践方式
- js框架中的css集成实践

### 超出滚动

水平方向滚动：`overflow: hidden; overflow-x: scroll;`

垂直方向滚动：`overflow: hidden; overflow-y: auto;

移动端页面超出滚动：

 ```css
.home {
  width: 100%;
  height: 100%;
  overflow: hidden;
  overflow-y: auto;
}
 ```

### 内容省略

```css
// 文本最多两行展示
.text-line-2 {
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-word;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  display: -webkit-box;
}
```

### 对齐方式

垂直居中 height === line-height、padding-top === padding-left、父display:flex;子align-self:center;

水平居中 margin: 0 auto;

### 生成三角形

```css
// 三角形
.caret {
  display: inline-block;
  width: 0;
  height: 0;
  border-top: px2rem(8) solid $mainColor;
  border-left: px2rem(6) solid transparent;
  border-right: px2rem(6) solid transparent;
}
```



## js

几道面试题

- js 中使用 typeof 能得到的哪些类型  （js 变量类型）
- 何时使用 === 何时使用 == （强制类型转换）
- window.onload 和 DOMContentLoaded 的区别 （浏览器渲染过程）
- 用 JS 创建 10 个 `<a>`标签，点击的时候弹出对应的序号 （作用域）
- 简述如何实现一个模块加载器，实现类似 require.js 的基本功能 （js 模块化）
- 实现数组的随机排序 （js基础算法）

### js基础

- 原型 原型链
- 作用域 闭包
- 异步 单线程

#### 变量类型与计算

- 变量类型：值类型、引用类型（对象、数组、函数）
- 变量计算

**强制类型转换**

- 字符串拼接

  - ```js
    var a = 100 + 10 // 110
    var b = 100 + '10' // '10010'
    ```

- == 运算符

  - ```js
    100 == '100' // true
    0 == '' // true
    null == undefined // true
    ```

- if 语句

  - ```js
    var a = true;if (a) {};
    var b = 100; if (b) {};
    var c = ''; if (c) {};
    ```

- 逻辑运算

  - ```js
    console.log(10 && 0) // 0
    console.log('' || 'abc') // 'abc'
    console.log(!window.abc) // true
    // 判断一个变量会被当成 true 还是 false
    var a = 100
    console.log(!!a)
    ```

#### 面试题

- js 中使用 typeof 能得到哪些类型
- 何时使用 === 何时使用 == 
- js 中有哪些内置函数
- js 变量按照存储方式区分为哪些类型，并描述其特点
- 如何理解 JSON

##### js 中使用 typeof 能得到哪些类型

```js
typeof undefined // undefined
typeof 'abc' // string
typeof 123 // number
typeof true // boolean
typeof {} // object
typeof [] // object
typeof null // object
typeof console.log // function
```

##### 何时使用 === 何时使用 ==

除了下面这种全部用 ===

```js
if (obj.a == null) {
	// 这里相当于 obj.a === null || obj.a === undefined，简写形式
  // 这里是 jquery 源码中推荐的写法
}
```

##### JS中有哪些内置函数 __ 数据封装类对象

Object、Array、Function、Boolean、Number、String、Date、RegExp、Error

##### JS按存储方式区分变量类型

值类型、引用类型

##### 如何理解JSON

JSON 只不过是一个 JS 对象而已

```js
JSON.stringify({a:10, b:20})
JSON.parse('{"a": 10, "b": 20}')
```

#### 原型和原型链

- 构造函数
- 构造函数 - 扩展
- 原型规则和示例
- 原型链
- instanceof

**构造函数**

```js
function Foo(name, age) {
  this.name = name
  this.age = age
  this.class = 'class-1'
  // return this // 默认有这一行
}
var f = new Foo('zhangsan', 20)
```

**构造函数 - 扩展**

- var a = {}  其实是 var a = new Object() 的语法糖
- var a = [] 其实是 var a = new Array() 的语法糖
- function Foo() {...} 其实是 var Foo = new Function(...)
- 使用 instanceof 判断一个变量是否是一个数组的构造函数 -> instanceof Array

**原型规则和示例**

5条原型规则（原型链的基础）

- 所有的引用类型(数组、对象、函数)，都具有对象特性，即可自由扩展属性（除了“null”以外）。
- 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象。
- 所有的函数，都有一个 prototype 属性，属性值也是一个普通的对象。
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的“prototype”属性值。
- 当试图得到一个对象的某个属性时，如果这个对象本身本身没有这个属性，那么会去它的`__proto__`（即它的构造函数的 prototype）中寻找。

```js
// 前 4 条规则
var obj = {}; obj.a = 100;
var arr = []; arr.a = 100;
function fn () {}
fn.a = 100;

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

console.log(obj.__proto__ === Object.prototype)
// 第 5 条规则
function Foo(name, age) {
  this.name = name
}
Foo.prototype.alertName = function() {
  alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function() {
  console.log(this.name)
}
// 测试
f.printName()
f.alerName()
```

循环对象自身的属性

```js
var item
for (item in f) {
  // 高级浏览器已经在 for in 中屏蔽了来自原型的属性
  // 但这里还是建议加上这个判断，保证程序的健壮性
  if (f.hasOwnProperty(item)) {
    console.log(item)
	}
}
```

**原型链**

```js
// 构造函数
function Foo(name, age) {
  this.name = name
}
Foo.prototype.alertName = function () {
  alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function () {
  console.log(this.name)
}
// 测试
f.printName()
f.alertName()
f.toString() // 要去 f.__proto__.__proto__中查找
```

![1571907714695](./img/js-原型链-示例.png)

**instanceof**

用于判断**引用类型**属性哪个**构造函数**的方案，原理也是基于原型链向上查找规则。

#### 面试题

##### 如何准确判断一个变量是数组类型

```js
var arr = []
arr instanceof Array // true
Arra.isArray(arr) // true
```

##### 写一个原型链继承的例子

简单的例子（**面试减分。。。**）

```js
// 动物
function Animal() {
  this.eat = function() {
    console.log('animal eat')
  }
}
// 狗
function Dog() {
  this.bark = function() {
    console.log('dog bark')
  }
}
Dog.prototype = new Animal()
// 哈士奇
var hashqi = new Dog()
```

实用的例子 -- 封装DOM查询

```js
function Elem(id) {
  this.elem = document.getElementById(id)
}

Elem.prototype.html = function (val) {
  var elem = this.elem
  if (val) {
    elem.innerHTML = val
    return this // 链式操作
  } else {
    return elem.innerHTML
  }
}

Elem.prototype.on = function ()


var div1 = new Elem('div1')
// 测试
console.log(div1.html())
```

##### 描述 new 一个对象的过程

- 创建一个对象
- this 指向这个对象
- 执行代码，即对 this 赋值
- 返回 this

```js
function Foo(name, age) {
  this.name = name
  this.age = age
  this.class = 'class-1'
  // return this // 默认有这一行
}
var f = new Foo('zhangsan', 20)
```

##### zepto (或其他框架) 源码中如何使用原型链

- 慕课 “zepto设计和源码分析”

#### 作用域和闭包 

- 执行上下文

- this

- 作用域

- 作用域链

- 闭包

**执行上下文**

- 范围：一段`<script>`或者一个函数
- 全局：变量定义、函数声明
- 函数：变量定义、函数声明、this、arguments

> 注意 "函数声明"和"函数表达式"的区别

```js
console.log(a) // undefined
var a = 100

fn('zhangsan') // 'zhangsan' 20
function fn(name) {
  age = 20
  console.log(name, age)
  var age
}
```

**this**

- this 要在执行时才能确定值，定义时无法确认

```js
var a = {
  name: 'A',
  fn: function () {
    console.log(this.name)
  }
}
a.fn() // this === a
a.fn.call({name: 'B'}) // this === {name: 'B'}
var fn1 = a.fn
fn1() // this === window
```

使用 this 的几种场景

- 作为构造函数执行
- 作为对象属性执行
- 作为普通函数执行
- call apply bind

**作用域**

- 没有块级作用域
- 只有函数和全局作用域

```js
// 无块级作用域
if (true) {
  var name = 'zhangsan'
}
console.log(name)

// 函数和全局作用域
var a = 100
function fn() {
  var a = 200
  console.log('fn', a)
}
console.log('global', a)
fn()
```

**作用域链**

本身作用域没有变量，会继续向上查找

**闭包**

闭包的使用场景

- 函数作为返回值
- 函数作为参数传递
  - react 中父组件向子组件传递方法也是闭包

函数作为返回值的例子

```js
function F1() {
  var a = 100
  
  // 返回一个函数(函数作为返回值)
  return function() {
    console.log(a) // 自由变量，父作用域寻找
  }
}

// f1 得到一个函数
var f1 = F1()
var a = 200
f1() // 100

// 函数作为参数传递
var f2 = F1()

function F2(fn) {
  var a = 200
  fn()
}
F2(f2) // 100
```

实际开发中闭包的应用

```js
// 闭包实际应用中主要用于封装变量，收敛权限
function isFirstLoad() {
	var _list = []
  return function(id) {
    if (_list.indexOf(id) >= 0) {
      return false
    } else {
      _list.push(id)
      return true
    }
  }
}

// 使用
var firstLoad = isFirstLoad()
firstLoad(10) // true
firstLosd(10) // false
firstLoad(20) // true
```

#### 面试题

##### 说一下对变量提升的理解

- 变量定义
- 函数声明（注意和函数表达式的区别）

##### 说明 this 几种不同的使用场景

- 作为构造函数执行
- 作为对象属性执行
- 作为普通函数执行
- call apply bind

##### 创建10个 `<a>`标签，点击时弹出来对应的序号

```js
for (var i = 0;; i < 10; i++) {
  (function (i) {
    var a = document.createElement('a')
    a.innerHTML = i + '<br>'
    a.addEventListener('click', function (e) {
      e.preventDefault()
      alert(i)
    })
    document.body.appendChild(a)
  })(i)
}
```

##### 如何理解作用域

- 自由变量
- 作用域链，即自由变量的查找
- 闭包的两个场景

##### 实际开发中闭包的作用

```js
// 闭包实际应用中主要用于封装变量，收敛权限
function isFirstLoad() {
	var _list = []
  return function(id) {
    if (_list.indexOf(id) >= 0) {
      return false
    } else {
      _list.push(id)
      return true
    }
  }
}

// 使用
var firstLoad = isFirstLoad()
firstLoad(10) // true
firstLosd(10) // false
firstLoad(20) // true
```

#### 异步和单线程

**异步**

```js
console.log(100)
setTimeout(function () {
  console.log(200)
}, 1000)
console.log(300)
```

**同步**

```js
console.log(100)
alert(200)
console.log(300)
```

**何时需要异步**

- 在可能发生等待的情况
- 等待过程中不能像 alert 一样阻塞程序运行
- “等待的情况”都需要异步

**前端使用异步的场景**

- 定时任务：setTimeout，setInterval
- 网络请求：：ajax 请求，动态 `<img>` 加载
- 事件绑定

ajax请求代码示例

```js
console.log('start')
$.get('./data1.json', function (data1) {
  console.log(data1)
})
console.log('end')
```

`<img>`加载示例

```js
console.log('start')
var img = document.createElement('img')
img.onload = function () {
  console.log('loaded')
}
img.src = './xxx.png'
console.log('end')
```

事件绑定示例

```js
console.log('start')
document.getElementById('btn1', addEventListener('click', function () {
  alert('clicked')
}))
console.log('end')
```

#### 面试题

##### 同步和异步的区别是什么？分别举一个同步和异步的例子

- 同步会阻塞代码执行，而异步不会
- alert 是同步， setTimeout 是异步 

##### 一个关于 setTimeout 的笔试题

```js
console.log(1)
setTimeout(function () {
  console.log(2)
}, 0)
console.log(3)
setTimeout(function () {
  console.log(4)
}, 1000)
console.log(5)
// 1、3、5、2、4
```

##### 前端使用异步的场景有哪些

- 定时任务：setTimeout，setInterval
- 网络请求：：ajax 请求，动态 `<img>` 加载
- 事件绑定

#### ES6 常用语法

ES6 常用语法： Class Module Promise 等

- 模块化的使用和编译环境
- Class与JS构造函数的区别
- Promise 的用法
- ES6 其他常用功能

**模块化的使用和编译环境**

export 语法

```js
// util1.js
export default {
	a: 100
}

// util2.js
export function fn1() {
  alert('fn1')
}
export function fn2() {
  alert('fn2')
}
```

import 语法

```js
// index.js
import util1 from './util1.js'
import { fn1, fn2 } from './util2.js'

console.log(util1)
fn1()
fn2()
```

关于 JS 众多模块化标准

- 没有模块化
- AMD 成为标准，require.js (也有 CMD)
- 前端打包工具，使得 nodejs 模块画化可以被使用
- ES6 出现，想统一现在所有模块化标准
- nodejs积极支持，浏览器尚未统一
- 你可以自造 lib，但是不要自造标准

开发环境-babel

开发环境-webpack

开发环境-rollup

**Class与JS构造函数的区别**

- JS 构造函数
- Class 基本语法
- 语法糖
- 继承

react 中 class 示例

```react
class Ad extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      data: []
    }
  }
  render() {
    return (
    	<div>hello iooc</div>
    )
  }
  componentDidMount() {
	}
}
```

JS 构造函数

```js
function MathHandle(x, y) {
  this.x = x
  this.y = y
}

MathHandle.prototype.add = function () {
  return this.x + this.y
}

var m = new MathHandle(1, 2)
console.log(m.add())

```

Class 语法

```js
Class MathHandle {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
  
  add() {
    return this.x + this.y
  }
}

const m = new MathHandle(1, 2)
console.log(m.add())
```

class 是语法糖

```js
class MathHandle {
  
}
typeof MathHandle
MathHandle === MathHandle.prototype.construtor
```

继承

继承- 构造函数

```js
function Animal() {
  this.eat = function () {
    console.log('animal eat')
  }
}

function Dog() {
  this.bark = function () {
		console.log('dog dark')
  }
}
Dog.prototype = new Animal()

var hashiqi = new Dog()
```

继承 - Class

```js
class Animal {
  constructor(name) {
    this.name = name
  }
  eat() {
    console.log(`${this.name} eat`)
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name)
    this.name = name
  }
  say() {
    console.log(`${this.name} say`)
  }
}
const dog = new Dog('哈士奇')
dog.say()
dog.eat()
```

**Promise 的基本使用**

- Callback Hell
- Promise 语法

Callback Hell

```js
function loadImg(src, callback, fail) {
  var img = document.createElement('img')
  img.onload = function () {
    callback(img)
  }
  img.onerror = function () {
    fail()
  }
  img.src = src
}

var src = 'http://www.imooc.com/static/img/index/logo_new.png'
loadImg(src, function (img) {
  console.log(img.width)
}, function () {
  console.log('failed')
})
```

Promise 语法

```js
function loadImg(src) {
  const promise = new Promise(function(resolve, reject) {
    var img = document.createElement('img')
    img.onload = function () {
      resovle(img)
    }
    img.onerror = function () {
      reject()
    }
    img.src = src
  })
  return promise
}

var src = 'http://www.imooc.com/static/img/index/logo_new.png'
var result = loadImg(src)

result.then(function (img) {
  console.log(img.width)
}, function () {
  console.log('failed')
})

result.then(function (img) {
  console.log(img.height)
})
```

**ES6 其他常用功能**

- let/const
- 多行字符串/模板变量
- 解构赋值
- 块级作用域
- 函数默认参数
- 箭头函数

#### 面试题

##### ES6模块化如何使用，开发环境如何打包

语法： import export (注意有无 default)

环境：label 编译 ES6 语法，模块化可用 webpack 和 rollup

扩展： 说一下自己对模块化标准统一的期待

##### Class 和普通构造函数有何区别

- Class 在语法上更加贴合面向对象的写法
- Class 实现继承更加易读、易理解 
- 更易于写 java 等后端语言的使用
- 本质上还是语法糖，使用 prototype

##### Promise 的基本使用和原理

- new Promise 实例，且要 return
- new Promise 时要传入函数，函数有 resolve reject 两个参数
- 成功时执行 resolve() 失败时执行 reject()
- then 监听结果

##### 总结一下 ES6 其他常用功能

#### 原型高级应用

**原型的实际应用**

- jquery 和 zepto 的简单使用
- zepto 如何使用原型
- jquery 如何使用原型

简单使用

```html
<p>jquery test 1</p>
<p>jquery test 2</p>
<p>jquery test 3</p>

<div id="div1">
  <p>jquery test in div</p>
</div>

<script type="text/javascript" src="./jquery-3.2.1.js"></script>
<script type="text/javascript">
  var $p = $('p')
  $p.css('color', 'red')
  console.log($p.html())
  
  var $div1 = $('#div1')
  $dvi1.css('color', 'blue')
  console.log($div1.html())
</script>
```

zepto 如何使用原型

```js
var zepto = {}
zepto.init = function (selector) {
  var slice = Array.prototype.slice
  var dom = slice.call(document.querySelectorAll(selector))
  return zepto.Z(dom, selector)
}

var $ = function(selector) {
  return zepto.init(selector)
}

function Z(dom, selector) {
  var i, len = dom ? dom.length : 0
  for (i = 0; i < len; i++) this.[i] = dom[i]
  this.length = len
  this.selector = selector || ''
}

zepto.Z = function(dom, selector) {
  return new Z(dom, selector)
}

$.fn = {
  constructor: zepto.Z,
  
  css: function (key, value) { },
  html: function (value) {}
}

zepto.Z.prototype = Z.prototype = $.fn
```

jquery 如何使用原型

```js
// my-jquery.js
(function (window) {
  var jQuery = function (selector) {
    // 注意 new 关键字，第一步就找到了构造函数
    return new jQuery.fn.init(selector)
  }
  
  jQuery.fn = {}

  // 定义构造函数
  var init = jQuery.fn.init = function (selector) {
    var slice = Array.prototype.slice
    var dom = slice.call(document.querySelectorAll(slector))

    var i, len = dom ? dom.length : 0
    for (i = 0; i < len; i++) this[i] = dom[i]
    this.length = len
    this.selector = selector || ''
  }
	// 初始化 jQuery.fn
  jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    css: function (key, value) {},
    html: function (value) {}
  }

  init.prototype = jQuery.fn
  
  window.$ = jQuery
})(window)
```

**如何体现原型的扩展性**

- 总结 zepto 和 jquery 原型的使用
- 插件机制

为什么要把原型方法放在 $.fn ?

```js
// 初始化 jQuery.fn
  jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    css: function (key, value) {},
    html: function (value) {}
  }

  init.prototype = jQuery.fn
```

最终目的是将插件属性放到jquery的原型中去

```js
$.fn.getNodeName = function () {
  return this.[0].nodeName
}
```

好处

- 只有 $ 会暴露在 window 全局变量
- 将插件扩展统一到 $.fn.xxx 这个接口，方便使用

#### 面试题

##### 原型如何实际应用

- 描述一个 jquery 如何使用原型
- 描述一下 zepto 如何使用原型
- 再结合自己的项目经验，说一个自己开发的例子

##### 原型如何满足扩展

- 说一下 jquery 和 zepto 的插件机制
- 结合自己的开发经验，做过的基于原型的插件

#### 异步全面讲解

异步全面讲解：从原理到 jQuery 再到 Promise

**什么是单线程，和异步的关系**

- 单线程 - 只有一个线程，只能做一件事
- 原因 - 避免 DOM 渲染的冲突
- 解决方案 - 异步

单线程 - 只能关注一件事

```js
// 循环运行期间，JS 执行和 DOM渲染暂时卡顿
var i, sum = 0;
for (i = 0; i < 1000000000; i++) {
  sum += i;
}
console.log(sum);

// alert 不处理，JS 执行和 DOM渲染暂时卡顿
console.log(1)
alert('hello')
console.log(2)
```

原因 - 避免 DOM 渲染冲突

- 浏览器需要渲染 DOM
- JS 可以修改 DOM 结构
- JS 执行时，浏览器 DOM 渲染会暂停
- 两段 JS 也不能同时执行（都修改 DOM 就冲突了）
- webworker 支持多线程，但是不能访问 DOM

解决方案 - 异步

```js
// setTimeout
console.log(100)
setTimeout(function () {
  console.log(200)
}, 1000)
console.log(300)
console.log(400)
// ajax请求
console.log(1)
$.ajax({
  url: 'xxxxx',
  success: function (result) {
    console.log(result)
  }
})
console.log(300)
console.log(400)
```

> 异步问题：
>
> 问题一：没按照书写方式执行，可读性差
>
> 问题二： callback 中不容易模块化

什么是 event-loop

- 事件轮询，JS 实现异步的具体解决方案
- 同步代码，直接执行
- 异步函数先放在**异步队列**中
- 待同步函数执行完毕，轮询执行**异步队列**的函数

例子1

```js
setTimeout(function () {
  console.log(100)
})
console.log(200)

// 主进程
console.log(200)
// 异步队列
function () {
  console.log(100)
}
```

例子2

```js
setTimeout(function () {
  console.log(1)
}, 100)
setTimeout(function () {
  console.log(2)
})
console.log(3)

// 主进程
console.log(3)
// 异步队列
//  立刻被放入
function () {
  console.log(2)
}
//  100ms 之后被放入
function () {
  console.log(1)
}
```

例子3

```js
$.ajax({
  url: 'xxx',
  success: function (result) {
    console.log('a')
  }
})
setTimeout(function () {
  console.log('b')
}, 100)
setTimeout(function () {
  console.log('c')
})
console.log('d')

// 主进程
console.log('d')
// 异步队列
//  立刻被放入
function () {
  console.log('c')
}
// 100ms 之后被放入
function () {
  console.log('b')
}
// ajax 加载完成时放入
function () {
  console.log('a')
}
```

**是否用过 jQuery 的 Deferred**

- jQuery 1.5 的变化
- 使用 jQuery Deferred
- 初步要引入 Promise 概念

jQuery 1.5 的变化 - 1.5 之前

```js
var ajax = $.ajax({	
	url: 'data.json',
  success: function () {
    console.log('success1')
    console.log('success2')
    console.log('success3')
  },
  error: function () {
    console.log('error')
  }
})
console.log(ajax) // 返回一个 xhr 对象
```

jQuery 1.5 的变化 - 1.5 之后

```js
var ajax = $.ajax('data.json')
ajax.done(function () {
    console.log('success 1')
  })
  .fail(function () {
  	console.log('error')
	})
  .done(function () {
  	console.log('success 2')
	})
console.log(ajax) // 返回一个 deferred 对象

// 很像 Promise 的写法
var ajax = $.ajax('data.json')
ajax.then(function () {
    console.log('success 1')
  }, function () {
    console.log('error 1')
  })
  .then(function () {
    console.log('success 2')
  }, function () {
    console.log('error 2')
  })

```

jQuery 1.5 的变化

- 无法改变 JS 异步和单线程的本质
- 只能从写法上杜绝 callback 这种形式
- 它是一种语法糖形式，但是解耦了代码
- 很好的体现：开放封闭原则（对扩展开放，对修改封闭）

使用 jQuery Deferred

- 总结，dtd 的 API 可分为两类，用意不同
- 第一类：dtd.resolve dtd reject
- 第二类：dtd.then dtd.done dtd.fail
- 这两类要分开使用！

```js
var wait = function () {
  var task = function () {
    console.log('执行完成')
  }
  setTimeout(task, 2000)
}
wait()
```

```js
function waitHandle() {
  var dtd = $.Deferred() // 创建一个 deferred 对象
  
  var wait = function (dtd) { // 要求传入一个 deferred 对象
    var task = function () {
      console.log('执行完成')
      dtd.resolve() // 表示异步任务已经完成 
      // dtd.reject() // 表示异步任务失败或出错
    }
    setTimeout(task, 2000)
    return dtd // 要求返回 deferred 对象
  }
  
  // 注意，这里一定要有返回值
  return wait(dtd)
}

var w = waitHandle()
w.then(function () {
  console.log('ok 1')
}, function () {
  console.log('err 1')
}).then(function () {
  console.log('ok 2')
}, function () {
  console.log('err 2')
})
// reject 的情况
var w = waitHandle()
w.then(function () {
  console.log('ok 1')
}, function () {
  console.log('err 1')
})
w.then(function () {
  console.log('ok 2')
}, function () {
  console.log('err 2')
})

// 由于 waitHandle 返回的是 dtd.promise，所以以下代码不能用resolve、reject
function waitHandle() {
  var dtd = $.Deferred() // 创建一个 deferred 对象
  
  var wait = function (dtd) { // 要求传入一个 deferred 对象
    var task = function () {
      console.log('执行完成')
      dtd.resolve() // 表示异步任务已经完成 
      // dtd.reject() // 表示异步任务失败或出错
    }
    setTimeout(task, 2000)
    return dtd.promise() // 要求返回 deferred 对象。注意，这里返回的是 promise 而不是直接返回 deferred 对象
  }
  
  // 注意，这里一定要有返回值
  return wait(dtd)
}

// 使用（B 员工）
var w = waitHandle() // promise 对象
$.when(w).then(function () {
	console.log('ok 1')
}, function () {
  console.log('err 1')
})
```

**Promise 的基本使用和原理**

- 基本语法
- 异常捕获
- 多个串联
- Promise.all 和 Promise.race
- Promise 标准

**异常捕获**

```js
result.then(function (img) {
  console.log(img.width)
}).then(function (img) {
  console.log(img.height)
}).catch(function (ex) {
  console.log(ex)
})
```

**多个串联**

```js
var src1='http:www/imooc.com/static/img/index/log_new.png'
var result1 = loadImg(src1)
var src2 = 'https://avatars3.githubusercontent.com/u/9583120'
var result2 = loadImg(src2)

// 链式操作
result1.then(function (img) {
  console.log('第一个图片加载完成')
  return result2 // 重要！
}).then(function (img) {
  console.log('第二个图片加载完成')
}).catch(function (ex) {
  // 最后统一 catch
  console.log(ex)
})
```

**Promise.all & Promise.race**

```js
// Promise.all 接收一个 promise 对象的数组
// 待全部完成之后，统一执行 success
Promise.all([result1, result2]).then(datas => {
  // 接收到的 datas 是一个数组，依次包含了多个 promise 返回的内容
  console.log(datas[0])
  console.log(datas[1])
})

// Promise.race 接收一个包含多个 promise 对象的数组
// 只要有一个完成，就执行 success
Promise.race([result1, result2]).then(data => {
  // data 即最先执行完成的 promise 的返回值
  console.log(data)
})
```

**Promise 标准**

- 关于“标准”的闲谈
- 状态变化
- then

关于“标准”的闲谈

- 任何技术推广使用都需要一套标准来支撑
- 任何不符合标准的东西，终将会被用户抛弃
- 不要挑战标准，不要自造标准

状态变化

- 三种变化：pending fulfilled rejected
- 初始状态是 pending
- pending 变为 fulfilled，或者 pedding 变为 rejected
- 状态变化不可逆

then

- Promise 实例必须实现 then 这个方法
- then() 必须可以接收两个函数作为函数
- then() 返回的必须是一个 Promise 实例（如果then没有明文返回Promise，就返回本身的Promise）

**async/await**

- then 只是将 callback 拆分了
- async/await 是最直接的同步写法
- 语法

then 只是将 calback 拆分了

```js
var w = waitHandle()
w.then(function () {
  console.log('ok 1')
}, function () {
  console.log('err 1')
}).then(function () {
  console.log('ok 2')
}, function () {
  console.log('err 2')
})
```

最直接的同步写法

```js
function loadImg(src) {
  const promise = new Promise(function () {
    var img = document.createElement('img')
    img.onload = function () {
      resolve(img)
    }
    img.onerror = function () {
      reject()
    }
    img.src = src
  })
  return promise
}

var src1='http:www/imooc.com/static/img/index/log_new.png'
var src2 = 'https://avatars3.githubusercontent.com/u/9583120'

const load = async function () {
	const result1 = await loadImg(src1)
  console.log(result1)
  const result2 = await loadImg(src2)
  console.log(result2)
}
load()
```

用法

- 使用 await，函数必须用 async 标识
- await 后面跟的是一个 Promise 实例
- 需要 babel-polyfill

```shell
npm - --save-dev babel-polyfill
```

**总结一下当前JS解决异步的方案**



#### 面试题

##### 什么是单线程，和异步有何关系

- 单线程就是同时只能做一件事，两段 JS 不能同时执行
- 原因就是为了避免 DOM 渲染的冲突
- 异步是一种“无奈”的解决方案，虽然有很多问题

##### 什么是 event-loop

- 事件轮询，JS 异步的解决方案
- 什么是异步队列，何时被放入异步队列
- 轮询的过程

##### 是否用过 jQuery 的 Deferred

- 可以 jQuery 1.5 对 ajax 的改变举例
- 说明如何简单的封装、使用 Deferred
- 说明 promise 和 Deferred 的区别

##### Promise 的基本使用和原理

- 基本语法
- 如何异常捕获（Error 和 reject 都要考虑）
- 多个串联 - 链式执行的好处
- Promise.all 和 Promise.race
- Pormise 标准 - 状态变化，then 函数

##### 介绍一下 async/await(和 Promise 的区别、联系)

- 基本语法
- 使用了 Promise，并没有和 Promise 冲突
- 完全是同步的写法，再也没有回调函数
- 但是：改变不了 JS 单线程、异步的本质

##### 总结一下当前JS解决异步的方案

- jQuery Deferred
- Promise
- Async/Await
- Generator(原理比较复杂、不是异步的直接替代方式、async/await更好，koa已“弃暗投明”)

#### 日期和math、数组api和对象api

日期

```js
Data.now() // 获取当前时间毫秒数
var dt = new Date()
dt.getTime() // 获取毫秒数
dt.getFullYear() // 年
dt.getMonth() // 月 (0 - 11)
dt.getDate() // 日 (0 - 31)
dt.getHours() // 小时（0 -23）
dt.getMinutes() // 分钟 （0 - 59）
dt.getSeconds() // 秒 (0 - 59)
```

Math

- 获取随机数 Math.random() ，在前端中的应用常用来清除缓存

数组api

- forEach 遍历所有元素
- every 判断所有元素是否都符合条件
- some 判断是否有至少一个元素符合条件
- sort 排序
- map 对元素重新组装，生成新数组
- filter 过滤符合条件的元素

对象api

```js
var obj = {
  x: 100,
  y: 200,
  z: 300
}
var key
for (key in obj) {
	// 注意这里的 hasOwnProperty
  if (obj.hasOwnProperty(key)) {
    console.log(key, obj[key])
  }
}
```

#### 面试题

##### 获取 2017-06-10 格式的日期

```js
function formatDate(dt) {
  if (!dt) {
    dt = new Date()
  }
  var year = dt.getFullYear()
  var month = dt.getMonth() + 1
  var date = dt.getDate()
  if (month < 10) {
    month = '0' + month
  }
  if (date < 10) {
    data = '0' + date
  }
  return year + '-' + month + '-' + date
}
var dt = new Date()
var formatDate = FormatDate(dt)
console.log(formatDate)
```

##### 获取随机数，要求是长度一致的字符串格式

```js
var random = Math.random()
var random = random + '0000000000' // 后面加上 10 个零
var random = random.slice(0, 10)
console.log(random)
```

##### 写一个能遍历对象和数组的通用 forEach 函数

```js
function forEach(obj, fn) {
  var key
  if (obj instanceof Array) {
    // 准确判断是不是数组
    obj.forEach(function (item, index) {
      fn(index, item)
    })
  } else {
    // 不是数组就是对象
    for (key in obj) {
      fn(key, obj[key])
    }
  }
}

var arr = [1, 2, 3]
// 注意，这里参数的顺序换了，为了和对象的遍历格式一致
forEach(arr, function (index, item) {
  console.log(index, item)
})

var obj = {x: 100, y: 200}
forEach(obj, function(key, value) {
  console.log(key, value)
})
```

### js-web-api

常说的JS（浏览器执行的JS）包含两部分：

- JS基础知识（ECMA262标准）
- JS-Web-APi（W3C标准）

W3C标准中关于 JS 的规定有：

- dom操作
- ajax
- 事件绑定
- ajax 请求 （包括 http 协议）
- 存储

全面考虑，JS内置的全局函数和对象有哪些？

#### DOM

DOM（Document Object Model）

- DOM本质
- DOM节点操作
- DOM结构操作

**DOM本质**

把获取的HTML代码，解析成浏览器能识别且 js 能操作的一个模型而已。

**DOM节点操作**

- 获取 DOM 节点
- prototype
- Attribute

获取DOM节点

```js
var div1 = document.getElementById('div1') // 元素
var divList = document.getElementByTagName('div') // 集合
console.log(divList.length)
console.log(divList[0])

var containerList = document.getElementsByClassName('.container') // 集合
var pList = document.querySelectorAll('p') // 集合
```

property

js 中的属性

```js
var pList = document.querySelectorAll('p')
var p = Plist[0]
console.log(p.style.width) // 获取样式
p.style.width = '100px' // 修改样式
console.log(p.className) // 获取 class
p.className = 'p1'

// 获取 nodeName 和 nodeType
console.log(p.nodeName)
console.log(p.nodeType)
```

Attribute

Attribute指的是真正的html代码中的文档标签的属性，并不是js对象的属性

```js
var pList = document.querySelectorAll('p')
var p = pList[0]
p.getAttribute('data-name')
p.setAttribute('data-name', 'imooc')
p.getAttribute('style')
p.setAttribute('style', 'font-size:30px;')
```

**DOM结构操作**

- 新增节点
- 获取父元素
- 获取子元素
- 删除节点

新增节点

```js
var div1 = document.getElementById('div1')
// 添加新节点
var p1 = document.createElement('p')
p1.innerHTML = 'this is p1'
div1.appendChild(p1) // 添加新创建的元素
// 移动已有节点
var p2 = document.getElementById('p2')
div1.appendChild(p2)
```

获取父元素和子元素

```js
var div1 = docuemnt.getElementById('div1')
var parent = div1.parentElement

var child = div1.childNOdes
div1.removeChild(child[0])
```

删除节点

```js
var div1 = document.getElementById('div1')
var child = div1.childNodes
div1.removeChild(child[0])
```

#### 面试题

##### DOM 是哪种基本的数据结构？

树

##### DOM 操作的常用 API 有哪些

- 获取DOM节点，以及节点的property和Attribute
- 获取父节点，获取子节点
- 新增节点，删除节点

##### DOM 节点的 attr 和 property 有何区别

- property 只是一个 JS 对象的属性的修改
- Attribute 是对 html 标签属性的修改

#### BOM

BOM（Browser Object Model）

- navigator
- screen
- location
- history

**navigator & screen**

```js
// navigator
var ua = navigator.userAgent
var isChrome = ua.indexOf('Chrome')
console.log(isChrome)

// screen
console.log(screen.width)
console.log(screen.height)
```

**location & history**

```js
// location
console.log(location.href)
console.log(location.protocal) // 'http: 'https:'
console.log(location.host)
console.log(location.pathname) // '/learn/199'
console.log(location.search)  // 查询参数
console.log(location.hash)

// history
history.back()
history.forward()
```

#### 面试题

##### 如何检测浏览器的类型

```js
var ua = navigator.userAgent
var isChrome = ua.indexOf('Chrome')
console.log(isChrome)
```

##### 拆解 url 的各部分

```js
// location
console.log(location.href)
console.log(location.protocal) // 'http: 'https:'
console.log(location.host)
console.log(location.pathname) // '/learn/199'
console.log(location.search)  // 查询参数
console.log(location.hash)
```

#### 事件

- 通用事件绑定
- 事件冒泡
- 代理

**通用事件绑定**

```js
var btn = document.getElementById('btn1')
btn.addEventListener('click', function (event) {
  console.log('click')
})

function bindEvent(elem, type, fn) {
  elem.addEventListener(type, fn)
}
var a = document.getElementById('link1')
bindEvent(a, 'click', function(e) {
  e.preventDefault() // 阻止默认行为
  alert('clicked')
})
```

> 关于IE低版本的兼容性 
>
> - IE低版本使用 attachEvent 绑定事件，和W3C标准不一样
> - IE低版本使用量已非常少，很多网站都早已不支持

**事件冒泡**

```html
<body>
  <div id="div1">
    <p id="p1">激活</p>
    <p id="p2">取消</p>
    <p id="p3">取消</p>
    <p id="p4">取消</p>
  </div>
  <div id="div2">
    <p id="p5">取消</p>
    <p id="p6">取消</p>

  </div>
</body>
```

```js
var p1 = document.getElementById('p1')
var body = document.body
bindEvent(p1, 'click', function (e) {
  e.stopPropatation()
  alert('激活')
})
bindEvent(body, 'click', function (e) {
	alert('取消')
})
```

**代理**

```html
<div id="div1">
  <a href="#">a1</a>
  <a href="#">a2</a>
  <a href="#">a3</a>
  <a href="#">a4</a>
  <!-- 会随时新增更多 a 标签 -->
</div>
```

```js
var div = document.getElementById('div1')
div1.addEventListener('click', function (e) {
  var target = e.target
  if (target.nodeName === 'A') {
    alert(target.innerHTML)
  }
})
```

完善通用绑定事件的函数

```js
function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
  }
  elem.addEventListener(type, function (e) {
    var target
    if (selector) {
      target = e.target
      if (target.matches(selector)) {
        fn.call(target, e)
      }
    } else {
      fn(e)
    }
  })
}

// 使用代理
var div1 = document.getElementById('div1')
bindEvent(div1, 'click', 'a', function (e) {
  console.log(this.innerHTML)
})
// 不使用代理
var a = document.getElementById('a1')
bindEvent(div1, 'click', function (e) {
  console.log(a.innerHTML)
})
```

>  代理的好处
>
> - 代码简洁
> - 减少浏览器内存占用

#### 面试题

##### 编写一个通用的事件监听函数

完善通用绑定事件的函数

```js
function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
  }
  elem.addEventListener(type, function (e) {
    var target
    if (selector) {
      target = e.target
      if (target.matches(selector)) {
        fn.call(target, e)
      }
    } else {
      fn(e)
    }
  })
}

// 使用代理
var div1 = document.getElementById('div1')
bindEvent(div1, 'click', 'a', function (e) {
  console.log(this.innerHTML)
})
// 不使用代理
var a = document.getElementById('a1')
bindEvent(div1, 'click', function (e) {
  console.log(a.innerHTML)
})
```

##### 描述事件冒泡流程

- DOM树形结构
- 事件冒泡
- 阻止冒泡
- 冒泡的应用

##### 对于一个无线下拉加载图片的页面，如何给每个图片绑定事件

- 使用代理
- 知道代理的两个优点

#### Ajax

- XMLHttpRequest
- 状态码说明
- 跨域

**XMLHttpRequest**

```js
var xhr = new XMLHttpRequest()
xhr.open('GET', '/api', false)
xhr.onreadystatechange = function () {
	// 这里的函数异步执行
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      alert(xhr.responseText)
    }
  }
}
xhr.send(null)
```

> IE 兼容性问题
>
> IE低版本使用 ActiveXObject，和W3C标准不一样
>
> IE低版本使用量已非常少，很多网站都早已不支持

**状态码说明**

readyState

- 0 - (未初始化) 还没有调用send()方法
- 1 - (载入) 已调用send()方法，正在发送请求
- 2 - (载入完成) send() 方法执行完成，已经接收到全部响应内容
- 3 - (交互) 正在解析响应内容
- 4 - (完成) 响应内容解析完成，可以在客户端调用了

status

- 2xx - 表示成功处理请求，如 200
- 3xx - 需要重定向，浏览器直接跳转
- 4xx - 客户端请求错误，如 404
- 5xx - 服务端错误

**跨域**

- 什么是跨域
- JSONP
- 服务端设置 http header

什么是跨域

- 浏览器有同源策略，不允许 ajax 访问其他域接口
- 跨域条件：协议、域名、端口，有一个不同就算跨域

> 可以跨域的三个标签（可以跨域加载资源）：
>
> `<img src=xxx>`  可以做防盗链处理，如百度、知乎，不过和浏览器无关
>
> `<link href=xxx>`
>
> `<script src=xxx>`
>
> 三个标签的场景：
>
> `<img>`用于打点统计，统计网站可能是其他域
>
> `<link><script>`可以使用CDN，CDN的也是其他域
>
> `<script>`可以用与JSONP

跨域注意事项

- 所有的跨域请求都必须经过信息提供方允许
- 如果未经允许即可获取，那是浏览器同源策略出现漏洞

**JSONP实现原理**

- 加载 http://coding.m.imooc.com/classindex.html
- 不一定服务器端真正有一个 classindex.html 文件
- 服务器可以根据请求，动态生成一个文件，返回
- 同理，`<script src="http://coding.m.imooc.com/api.js">`

> - 例如你的网站要跨域访问慕课网的一个借口
> - 慕课给你一个地址 http://coding.m.imooc.com/api.js
> - 返回内容格式如 callback({x:100, y: 200})(可动态生成)
>
> ```js
> <script>
>   window.callback = function (data) {
>   	// 这是我们跨域得到信息
>   	cosnole.log(data)
> 	}  
> }
> </script>
> <script src="http://coding.m.imooc.com/api.js"></script>
> <!-- 以上将返回 callback({x:100, y:200}) -->
> ```

**服务端设置 http header**

- 另外一个解决跨域的简洁方法，需要服务器端来做
- 是将来解决跨域问题的一个趋势

```js
// 注意：不同后端语言的写法可能不一样

// 第二个参数填写允许跨域的域名城，不建议直接写 “*”
response.setHeader("Access-Control-Allow-Origin", "http://a.com, http://b.com")
response.setHeader("Access-Control-Allow-Headers", "X-Requested-With")
response.setHeader("Access-Control-Allow-Methods", "PUT, POST, GET, DELETE, OPTIONS")

// 接收跨域的cookie
response.setHeader("Access-Control-Allow-Credentials", "true")
```

#### 面试题

##### 手写ajax，不依赖第三方库

```js
var xhr = new XMLHttpRequest()
xhr.open('GET', '/api', false)
xhr.onreadystatechange = function () {
	// 这里的函数异步执行
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      alert(xhr.responseText)
    }
  }
}
xhr.send(null)
```

##### 跨域的几种实现方式

- JSONP
- 服务端设置 http header

#### 存储

- cookie
- localStorage 和 sessionStorage

**cookie**

- 本身用于客户端和服务端通信
- 但是它有本地存储的功能，于是就被“借用”
- 使用 document.cookie = ... 获取和修改即可

> cookie 用于存储的缺点：
>
> - 存储量太小，只有 4KB
> - 所有 http 请求都带着，会影响获取资源的效率
> - API 简单，需要封装才能用 document.cookie = ...

**localStorage 和 sessionStorage**

- HTML5 专门为存储而设计，最大容量5M
- API 简单易用
- localStorage.setItem(key, value);localStorage.getItem(key);

> - iOS safari 隐藏模式下
> - localStorage.getItem 会报错
> - 建议统一使用 try-catch 封装

#### 面试题

##### 请描述一下 cookie， sessionStorage 和 localStorage 的区别？

- 容量
- 是否会携带到 ajax 中
- api 易用性

### js开发环境  

- IDE（写代码的效率）
- git（代码版本管理，多人协作开发）
- JS 模块化
- 打包工具
- 上线回滚的流程

#### IDE

webstorm、sublime、vscode、atom

#### Git

- 正式项目都需要代码版本管理
- 大型项目需要多人协作开发
- Git和linux是一个作者
- 网络Git服务器如 coding.net github.com
- 一般公司代码非开源，都有自己的Git服务器

**常用Git命令**

```shell
git add .
git checkout xxx   # 改错了还原回去
git status 
git diff # 查看改了什么
git commit -m "xxx"
git push orgin master
git pull origin master
git branch 查看分支
git checkout -b xxx / git checkout xxx # 新建分支/切换分支
git merge xxx 合并
```

#### 模块化

- 不使用模块化的情况
- 使用模块化
- AMD
- CommonJS

**不使用模块化的情况**

- util.js getFormateDate 函数
- a-util.js aGetFormatDate函数 使用 getFormateDate
- a.js aGetFormatDate

```js
// util.js
function getFormatDate(date, type) {
  // type === 1 返回 2019-06-15
  // type === 2 返回 2019年6月15日
  // ...
}

// a-util.js
function aGetFormatDate(date) {
  // 要求返回 2019年6月15日 格式
  return getFormatDate(date, 2)
}

// a.js
var dt = new Date()
console.log(aGetFormatDate(dt))

// 使用
<script src="util.js"></script>
<script src="util.js"></script>
<script src="util.js"></script>
<!-- 1.全局变量污染：这些代码中的函数必须是全局变量，才能暴露给使用方。全局变量污染 -->
<!-- 2.强依赖关系：a.js 知道要引用 a-util.js, 但是不知道其依赖于 util.js -->
```

**使用模块化**

```js
// util.js
export {
  getFormatDate: function (date, type) {
    // type === 1 返回 2019-06-15
    // type === 2 返回 2019年6月15日
  }
}

// a-util.js
var getFormatDate = requrie('util.js')
export {
  aGetFormatDate: function (date) {
    // 要求返回 2019年6月15日 格式
    return getFormatDate(date, 2)
  }
}

// a.js
var aGetFormatDate = require('a-util.js')
var dt = new Date()
console.log(aGetFormatDate(dt))

// 直接 `<script src="a.js></script>`，其他的根据依赖关系自动引用
// 那两个函数，没必要做成全局变量，不会带来污染和覆盖
```

**AMD**

- require.js reqruie.js.org/
- 全局 define 函数
- 全局 require 函数
- 依赖JS会自动、异步加载

```js
// uitl.js
define(function () {
  return {
    getFormatDate: function (date, type) {
      if (type === 1) {
        return '2019-06-15'
      }
      if (type === 2) {
        return '2019年6月15日'
      }
    }
  }
})

// a-util.js
define(['./util.js'], function (util) {
  return {
    aGetFormatDate: function (date) {
      return util.getFormatDate(date, 2)
    }
  }
})

// a.js
define(['./a-util.js'], function (aUtil) {
  return {
    printDate: function (date) {
      console.log(aUtil.aGetFormatDate(date))
    }
  }
})

// main.js
requrie(['./a.js'], function (a) {
  var date = new Date()
  a.printDate(date)
})
```

使用 requrie.js

```html
<script src="/requrie.min.js" data-main="./main.js"></script>
```

**CommonJS**

- nodejs 模块化规范，现在被大量用与前端，原因：
- 前端开发依赖的插件的库，都可以从 npm 中获取
- 构建工具的高度自动化，使得使用 npm 的成本非常低
- **CommonJS 不会异步加载JS，而是同步一次性加载出来**

```js
// util.js
module.exports = {
  getFormatDate: function (date, type) {
    if (type === 1) {}
    if (type === 2) {}
  }
}

// a-util.js
var util = requrie('util.js')
module.exports = {
  aGetFormatdate: function (date) {
    return util.getFormatDate(date, 2)
  }
}
```

**AMD 和 CommonJS 的使用场景**

- 需要异步加载JS，使用 AMD
- 使用了 npm 之后建议使用 CommonJS

####上线和回滚

- 上线和回滚的基本流程
- linux基本命令

**上线回滚流程**

上线流程要点

- 将测试完成的代码提交到git版本库的masterffvi 
- 将当前服务器的代码全部打包并记录版本号，备份
- 将master分支的代码提交覆盖到线上服务器，生成新版本号

回滚流程要点

- 将当前服务器的代码打包并记录版本号，备份
- 将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号

**linux 基本命令**

- 服务器使用 linux 居多，server版，只有命令行
- 测试环境要匹配线上环境，因此也是 linux

```shell
ssh xxx # 登录
mkdir
ls
ll
cd cd ..
pwd # 当前目录
rm -rf xxx # 删除文件夹
cp a.js a1.js # 拷贝
mv a1.js src/a1.js # 移动
rm a.js # 删除文件
vim a.js # 打开编辑文件
i # 打开vim之后，点击 i 输入,按esc键退出insert状态,esc:w保存，esc:q退出
cat a.js # 查看文件内容
head a.js # 查看文件头部内容
tail a.js # 查看文件尾部内容
grep '2' a.js # 在文件中搜索
```

### 运行环境 

- 页面加载过程
- 性能优化
- 安全

#### 页面加载

- 加载资源的形式
- 加载一个资源的过程
- 浏览器渲染页面的过程

**加载资源的形式**

- 输入 url (或跳转页面) 加载 html
- http://coding.m.imooc.com
- 加载 html 中的静态资源
- `<script src="/static/js/jquery.js"></script>`

**加载一个资源的过程**

- 浏览器根据 DNS 服务器得到域名的 IP 地址
- 向这个 IP 的机器发送 http 请求
- 服务器收到、处理并返回 http 请求
- 浏览器得到返回内容

**浏览器渲染页面的过程**

- 根据 HTML 结构生成 DOM Tree
- 根据 CSS 生成 CSSOM（为什么把css放在head里）
- 将 DOM 和 CSSOM 整合形成 RenderTree
- 遇到 `<script>`时，会执行阻塞渲染（为什么把js放在body尾部）

#### 面试题

##### 从输入url到得到html的详细过程

**加载一个资源的过程**

- 浏览器根据 DNS 服务器得到域名的 IP 地址
- 向这个 IP 的机器发送 http 请求
- 服务器收到、处理并返回 http 请求
- 浏览器得到返回内容

**浏览器渲染页面的过程**

- 根据 HTML 结构生成 DOM Tree
- 根据 CSS 生成 CSSOM（为什么把css放在head里）
- 将 DOM 和 CSSOM 整合形成 RenderTree
- 遇到 `<script>`时，会执行阻塞渲染（为什么把js放在body尾部）

##### window.onload 和 DOMContentLoaded 的区别

```js
window.addEventListener('load', function () {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
window.addEventListener('DOMContentLoaded', function () {
  // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

#### 性能优化

原则

- 多使用内存、缓存或者其他方法
- 减少 CPU计算、减少网络

从哪里入手

- 加载页面和静态资源
- 页面渲染

**加载资源优化**

- 静态资源的压缩合并
- 静态资源缓存
- 使用 CDN 让资源加载更快
- 使用 SSR 后端渲染，数据直接输出到 HTML 中 

**渲染优化**

- CSS放前面，JS 放后面
- 懒加载（图片懒加载、下拉加载更多）
- 减少 DOM查询，对 DOM查询做缓存
- 减少DOM操作，多个操作尽量合并在一起执行
- 事件节流
- 尽早执行操作（如 DOMContentLoaded）

资源合并

```
<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>

<script src="abc.js"></script>
```

缓存

- 通过链接名称控制缓存
- `<script src="abc_1.js"></script>`
- 只有内容改变的时候，链接名称才会改变
- `<script src="abc_2.js"></script>`

使用 CDN，比自己服务器快

使用 SSR 后端渲染

- 现在 Vue React 提出了这样的概念
- 其实 jsp php asp 都属于后端渲染

懒加载

```html
<img id="img1" src="preview.png" data-realsrc="abc.png"/>
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.src = img1.getAttribute('data-realsrc')
</script>
```

缓存 DOM 查询

```js
// 未缓存 DOM 查询
var i
for (i = 0; i < document.getElementsByTagName('p').length;i++) {
  // todo
}

// 缓存了 DOM 查询
var pList = document.getElementsByTagName('p')
var i 
for (i =0; i < pList.length; i++) {
  // todo
}
```

合并 DOM 插入

```js
var listNode = document.getElementById('list')

// 要插入 10 个 li 标签
var frag = document.createDocumentFragment()
var x, li;
for(x = 0; x < 10; x++) {
  li = document.createElement('li')
  li.innerHTML = 'List item' + x
  frag.appendChild(li)
}

listNode.appendChild(frag)
```

事件节流

```js
var textarea = document.getElementById('text')
var tiemeoutId
textarea.addEventListener('keyup', function () {
  if (timeoutId) {
    cleaerTimeout(timeoutId)
  }
  timeoutId = setTimeout(function () {
    // 触发 change 事件
  }, 100)
})
```

尽早操作

```js
window.addEventListener('load', function () {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
window.addEventListener('DOMContentLoaded', function () {
  // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

#### 安全性

综合性的问题：场景的前端安全问题有哪些

- XSS 跨站请求攻击
- XSRF 跨站请求伪造

**XSS**

- 在新浪博客写一篇文章，同时偷偷插入一段`<script>`
- 攻击代码中，获取 cookie，发送到自己的服务器
- 发布博客，有人查看博客内容
- 会把查看者的 cookie 发送到攻击者的服务器

> 防御手段：替换
>
> - 前端替换关键词，例如替换 < 为 `&lt;` > 为 `&gt;`
> - 后端替换

**XSRF**

- 你已登录一个购物网站，正在浏览器商品
- 改网站付费接口是xxx.com/pay?id=100 但是没有任何验证
- 然后你收到一封邮件，隐藏着 `<img src=xxx.com/pay?id=100>`
- 你查看邮件的是时候，就已经悄悄的付费购买了

> 增加验证流程，如输入指纹、密码、短信验证码（主要是后端来做）

### 数字相关

获取随机整数区间

```js
function getNumberIn(start, end) {
	return Math.floor(Math.random() * (end- start) + start)
}
```

### dom操作

获取元素的高度

```js
$le.clientHeight
```

页面滚动距离

监听页面根元素的 scroll 事件，通过 event.target.scrollTop

## 框架原理

- 虚拟DOM：存在价值，如何使用，diff 算法
- vue：MVVM，vue 响应式、模板解析、渲染
- React：组件化、JSX、vdom、setState

### 虚拟 DOM

**什么是 vdom，为何使用 vdom**

- 什么是 vdom
- 设计一个需求场景
- 用 jQuery 实现
- 遇到的问题

什么是 vdom

- virtual dom，虚拟 DOM
- 用 JS 模拟 DOM 结构
- DOM 变化的对比，放在 JS层来做（图灵完备语言）
- 提高重绘性能

```html
<ul id="list">
  <li class='item'>Item 1</li>
  <li class='item'>Item 2</li>
</ul>
```

js 模拟

```js
{
  tag: 'ul',
  attrs: {
    id: 'list'
  },
  children: [
    {
      tag: 'li',
      attrs: { className: 'item' },
      children: ['Item 1']
    },
    {
      tag: 'li',
      attrs: { className: 'item' },
      children: ['Item 2']
    }
  ]
}
```

设计一个需求场景

```js
[
  {
    name: '张三',
    age: '20',
    address: '北京'
  },
  {
    name: '李四',
    age: '21',
    address: '上海'
  },
  {
    name: '王五',
    age: '22',
    address: '广州'
  }
]
```

用 jQuery 实现

```html
<div id="container"></div>
<button id="btn-change">change</button>

<script type="text/javascript" src="./jquery-3.2.1.js"></script>
<script type="text/javascript">
  var data = [
    {
      name: '张三',
      age: '20',
      address: '北京'
    },
    {
      name: '李四',
      age: '21',
      address: '上海'
    },
    {
      name: '王五',
      age: '22',
      address: '广州'
    }
  ]
  
  // 渲染函数
  function render(data) {
    var $container = $('#container')
    // 清空容器，重要！！！
    $container.html('')
    
    // 拼接 table
    var $table = $('<table>')
    $table.append($('<tr><td>name</td><td>age</td><td>address</td></tr>'))
    data.forEach(function (item) {
      $table.append($('<tr><td>' + item.name + '</td><td>' + item.age + '</td><td>' + item.address + '</td></tr>'))
    })
    
    // 渲染到页面
    $container.append($table)
  }
  
  $('#btn-change').click(function () {
    data[1].age = 30
    data[2].address = '深圳'
    // re-render
    render(data)
  })
  
  // 页眉加载完成立即执行（初次渲染）
  render(data)
</script>
```

遇到的问题

- DOM 操作时 “昂贵”的，js 运行效率高
- 尽量减少 DOM 操作，而不是 “推倒重来”
- 项目越复杂，影响就越严重
- vdom 可以解决这个问题

```js
var div = document.createElement('div')
var item, result = ''
for (item in div) {
  result += ' | ' + item
}
console.log(result) // 内容非常多
```

**vdom 如何应用，核心 API 是什么**

- 介绍 snabbdom
- 重做之前的 demo
- 核心 API

介绍 snabbdom

![1572579075500](./img/vdom-snabbdom.png)

介绍 snabbdom - h 函数

```js
var vnode = h('ul#list', {}, [
  h('li.item', {}, 'Item 1'),
  h('li.item', {}, 'Item 2')
])

{
  tag: 'ul',
  attrs: {
    id: 'list'
  },
  children: [
    {
        tag: 'li',
        attrs: { className: 'item' },
        children:: ['Item 1']
  },
    {
      tag: 'li',
        attrs: { className: 'item' },
          children: ['Item2']
    }
  ]
}
```

介绍 snabbdom - patch 函数

```js
var vnode = h('ul#list', {}, [
  h('li.item', {}, 'Item 1'),
  h('li.item', {}, 'Item 2')
])

var container = document.getElementById('container')
patch(container, vnode)

// 模拟改变
var btnChange = document.getElementById('btn-change')
btnChange.addEventListener('click', function () {
  var newVnode = h('ul#list', [
    h('ul#list', {}, [
      h('li.item', {}, 'Item 111'),
      h('li.item', {}, 'Item 222'),
      h('li.item', {}, 'Item 333')
    ])
  ])
  
  patch(vnode, newVnode)
})
```

使用 vdom-snabbdom

```html
<body>
    <div id="container"></div>
    <button id="btn-change">change</button>

    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/h.js"></script>
    <script type="text/javascript">
        var snabbdom = window.snabbdom

        // 定义 patch
        var patch = snabbdom.init([
            snabbdom_class,
            snabbdom_props,
            snabbdom_style,
            snabbdom_eventlisteners
        ])

        // 定义 h
        var h = snabbdom.h

        var container = document.getElementById('container')

        // 生成 vnode
        var vnode = h('ul#list', {}, [
            h('li.item', {}, 'Item 1'),
            h('li.item', {}, 'Item 2')
        ])
        patch(container, vnode)

        document.getElementById('btn-change').addEventListener('click', function () {
            // 生成 newVnode
            var newVnode = h('ul#list', {}, [
                h('li.item', {}, 'Item 1'),
                h('li.item', {}, 'Item B'),
                h('li.item', {}, 'Item 3')
            ])
            patch(vnode, newVnode)
        })

    </script>
    
</body>
```

```js
<body>
    <div id="container"></div>
    <button id="btn-change">change</button>

    <script src="https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-class.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-props.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-style.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-eventlisteners.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.0/h.js"></script>
    <script type="text/javascript">
        var snabbdom = window.snabbdom
        // 定义关键函数 patch
        var patch = snabbdom.init([
            snabbdom_class,
            snabbdom_props,
            snabbdom_style,
            snabbdom_eventlisteners
        ])

        // 定义关键函数 h
        var h = snabbdom.h

        // 原始数据
        var data = [
            {
                name: '张三',
                age: '20',
                address: '北京'
            },
            {
                name: '李四',
                age: '21',
                address: '上海'
            },
            {
                name: '王五',
                age: '22',
                address: '广州'
            }
        ]
        // 把表头也放在 data 中
        data.unshift({
            name: '姓名',
            age: '年龄',
            address: '地址'
        })

        var container = document.getElementById('container')

        // 渲染函数
        var vnode
        function render(data) {
            var newVnode = h('table', {}, data.map(function (item) {
                var tds = []
                var i
                for (i in item) {
                    if (item.hasOwnProperty(i)) {
                        tds.push(h('td', {}, item[i] + ''))
                    }
                }
                return h('tr', {}, tds)
            }))

            if (vnode) {
                // re-render
                patch(vnode, newVnode)
            } else {
                // 初次渲染
                patch(container, newVnode)
            }

            // 存储当前的 vnode 结果
            vnode = newVnode
        }

        // 初次渲染
        render(data)


        var btnChange = document.getElementById('btn-change')
        btnChange.addEventListener('click', function () {
            data[1].age = 30
            data[2].address = '深圳'
            // re-render
            render(data)
        })

    </script>
</body>
```

总结

核心 API

- h('<标签名>', {...属性...}, [...子元素...])
- h('<标签名>', {...属性...}, '...')
- patch(container, vnode)
- patch(vnode, newVnode)

**介绍一下 diff 算法**

- 什么是 diff 算法
- 去繁就简
- vdom 为何用 diff 算法
- diff 算法的实现流程

**什么是 diff 算法**

示例1 - 命令行 diff

```js
// log1.txt
123
123
123

// log2.txt
123
1234
123

// 终端命令 diff log1.txt log2.txt，输出区别
```

示例2 - git diff 文件名

![1572659167800](./img/vdom-git-diff.png)

示例3

- diff 在线对比

**去繁就简**

- diff 算法非常复杂，实现难度很大，源码量很大
- 去繁就简，讲明白核心流程，不关心细节
- 面试官也大部分都不清楚细节，但是很关心核心流程

**vdom 为何用 diff 算法**

- DOM 操作是“昂贵”的，因此尽量减少 DOM 操作
- 找出本次 DOM 必须更新的节点来更新，其他的不更新
- 这个“找出”的过程，就需要 diff 算法

**diff 算法的实现流程**

- patch(container, vnode)
- patch(vnode, newVnode)

patch(container, vnode)

```js
// vnode
{
  tag: 'ul',
  attrs: {
    id: 'list'
  },
  children: [
    {
      tag: 'li',
      attrs: {
        className: 'item'
      },
      children: ['Item 1']
    }
  ]
}
// 通过 vonode 生成的真实dom节点
<ul id='list'>
  <li class='item'>Item 1</li>
</ul>
```

模拟代码（伪代码）

```js
function createElement(vnode) {
  var tag = vnode.tag
  var attrs = vnode.attrs || {}
  var children = vnode.children || []
  if (!tag) {
    return null
  }
  // 创建元素
  var elem = document.createElement(tag)
  // 属性
  var attrName
  for (attrName in attrs) {
    if (attrs.hasOwnProperty(attrName)) {
      // 给 elem 添加属性
      elem.setAttribute(attrName, attrs[attrName])
    }
  }
  // 子元素
  children.forEach(function (childNode) {
    // 给 elem 添加子元素
    elem.appendChild(createElement(childNode)) // 递归
  })
  // 返回真实的 DOM 元素
  return elem
}
```

patch(vnode, newVnode)

```json
// vnode
{
  tag: 'ul',
  attrs: { id: 'list' },
  children: [
    {
      tag: 'li',
      attrs: { className: 'item' },
      children:: ['Item 1']
    },
    {
      tag: 'li',
      attrs: { className: 'item' },
      children: ['Item 2']
    }
  ]
}
// newVnode
{
  tag: 'ul',
  attrs: { id: 'list' },
  children: [
    {
      tag: 'li',
      attrs: { className: 'item' },
      children:: ['Item 1']
    },
    {
      tag: 'li',
      attrs: { className: 'item' },
      children: ['Item 222']
    },
		{
      tag: 'li',
      attrs: { className: 'item' },
      children: ['Item 3']
    }
  ]
}
```

模拟代码（伪代码）

```js
function updateChildren(vnode, newVnode) {
  var children = vnode.children || []
  var newChildren = newVnode.children || []
  
 	// 遍历现有的 children
  children.forEach(function (child, index) {
    var newChild = newChildren[index]
    if (newChild === null) {
      return
    }
    if (child.tag === newChild.tag) {
      // 两者 tag 一样
      updateChildren(child, newChild)
    } else {
      // 两者 tag 不一样
      replaceNode(child, newChild)
    }
  })
}
```

**不仅仅是以上内容**

- 节点新增和删除
- 节点重新排序
- 节点属性、样式、事件绑定
- 如何极致压榨性能
- ....

**总结 - diff 实现过程**

- patch(container, vnode) 和 patch(vnode，newVnode)
- createElement
- updateChildren

#### 面试题

##### 什么是vdom，为何会存在 vdom？

- virtual dom，虚拟 DOM
- 用 JS 模拟 DOM 结构
- DOM 操作非常“昂贵”
- 将 DOM 对比操作放在 JS 层，提高效率

##### vdom 的如何应用，核心 API 是什么

- 如何使用？可用 snabbdom 的用法来举例
- 核心 API：h 函数、patch 函数

##### 介绍一下 diff 算法

- 知道什么是 diff 算法，是 linux 的基础命令
- vdom 中应用 diff 算法是为了找出需要更新的节点
- diff 实现，patch(container,vnode) patch(vnode, newVnode)
- 核心逻辑，createElement 和 updateChildren

### vue

#### MVVM

**说一下使用 jquery 和使用框架的区别**

- jQuery 实现 todo-list
- vue 实现 todo-list
- jQuery 和框架的区别

jQuery 实现 todo-list

```html
<div>
  <input type="text" name="" id="txt-title">
  <button id="btn-submit">submit</button>
</div>
<div>
  <ul id="ul-list"></ul>
</div>

<script type="text/javascript" src="./jquery-3.2.1.js"></script>
<script type="text/javascript">
  var $txtTitle = $('#txt-title')
  var $ulList = $('#ul-list')
  var $btnSubmit = $('#btn-submit')
  $btnSubmit.click(function () {
    var title = $txtTitle.val()
    var $li = $('<li>' + title + '</li>')
    $ulList.append($li)
    $txtTitle.val('')
  })
</script>
```

vue 实现 todo-list

```html
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
<script type="text/javascript" src="./vue-2.5.1.js"></script> <!-- 直接使用cdn也行-->
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      title: '',
      list: []
    },
    methods: {
      add: function () {
        this.list.push(this.title)
        this.title = ''
      }
    }
  })
</script>
```

两者的区别

- 数据和视图的分离
- 以数据驱动视图

**对 MVVM 的理解**

- MVC
- MVVM
- 关于 ViewModel

MVC

- M - Model 数据
- V - View 视图、界面
- C - Controller 控制器、逻辑处理

![1572747983700](./img/MVVM-MVC.png)

![1572748058954](./img/MVVM-MVC2.png)

MVVM

- Model - 模型、数据
- View - 视图、模板（视图和模型是分离的）
- ViewModel - 连接 Model 和 View

```html
<!-- V View 视图 -->
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
<script type="text/javascript" src="./vue-2.5.1.js"></script> <!-- 直接使用cdn也行-->
<script type="text/javascript">
  // VM View Model View和Model之间的桥
  var vm = new Vue({
    el: '#app',
    // M Model 模型
    data: {
      title: '',
      list: []
    },
    methods: {
      add: function () {
        this.list.push(this.title)
        this.title = ''
      }
    }
  })
</script>
```

![1572748386722](./img/MVVM.png)

关于 ViewModel

- MVVM 不算是一种创新
- 但其中的 ViewModel 的确是一种创建
- 真正结合前端场景应用的创建

#### MVVM 框架的三大要素
- 再次分析 demo
- 三要素总结

##### 再次分析 demo

```html
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
<script type="text/javascript" src="./vue-2.5.1.js"></script> <!-- 直接使用cdn也行-->
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      title: '',
      list: []
    },
    methods: {
      add: function () {
        this.list.push(this.title)
        this.title = ''
      }
    }
  })
</script>
```

##### 三要素

- 响应式：vue 如何监听到 data 的每个属性变化？
- 模板引擎：vue 的模板如何被解析，指令如何处理？
- 渲染：vue 的模板如何被渲染成 html ? 以及渲染过程

**vue 中如何实现响应式**

- 什么是响应式
- Object.defineProperty
- 模拟

什么是响应式

- 修改 data 属性之后，vue 立刻监听到
- data 属性被代理到 vm 上
- 演示

```html
<div id="app">
  <p>{{name}}</p>
  <p>{{age}}</p>
</div>
<script type="text/javascript" src="./vue-2.5.1.js"></script> <!-- 直接使用cdn也行-->
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      name: 'zhangsan',
      age: 20
    }
  })
</script>
```

可以通过 vm.name = 'lisi' 修改，页面会理解发生变化

- data的数据怎么代理到 vm 上的
- vm修改数据怎么监听的

Object.defineProperty

```js
var obj = {
  name: 'zhangsan',
  age: 25
}
console.log(obj.name)
obj.age = 26

// 使用 Object.defineProperty 做数据劫持
var obj = {}
var _name = 'zhangsan'
Object.definedProperty(obj, 'name', {
  get: function () {
    console.log('get')
    return _name
  },
  set: function (newVal) {
    console.log('set')
    _name = newVal
  }
})

console.log(obj.name)
obj.name = 'lisi'
```

模拟实现

```js
var vm = {}
var data = {
  price: 100,
  name: 'zhangsan'
}

var key,value
for (key in data) {
  (function (key) {
    Object.defineProperty(vm, key, {
      get: function () {
        console.log('get') // 监听
        return data[key]
      },
      set: function (newVal) {
        console.log('set') // 监听
        data[key] = newVal
      }
    })
  })(key)
}
```

**vue 如何解析模板**

- 模板是什么
- render 函数
- render 函数与 vdom

模板是什么

- 本质：字符串
- 有逻辑，如 v-if v-for 等
- 与 html 格式很像，但是有很大区别
- 最终还要转换为 html 来显示
- 模板最终必须转换成 JS 代码，因为：
- 有逻辑（v-if v-for），必须用 JS 才能实现（图灵完备）
- 转换为 html 渲染页面，必须用 JS 才能实现
- 因此，模板最重要转换成一个 JS 函数（render 函数）

```vue
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
```

render 函数 - with 的用法

```js
var obj = {
  name: 'zhangsan',
  age: 20,
  getAddress: function () {
    alert('beijing')
  }
}

// 不用 with
function fn() {
  alert(obj.name)
  alert(obj.age)
  obj.getAddress()
}
fn()
```

```js
var obj = {
  name: 'zhangsan',
  age: 20,
  getAddress: function () {
    alert('beijing')
  }
}

// 使用 width
function fn1() {
  with(obj) {
    alert(name)
    alert(name)
    getAddress()
  }
}
fn1()
```

**render 函数**

- 模板中所有信息都包含在了 render 函数中
- this 即 vm
- price 即 this.price 即 vm.price，即 data 中的 price
- _c 即this._c 即 vm._c

```html
<div id="app">
  <p>{{price}}</p>
</div>
<script src="./vue-2.5.9.js"></script>
<script>
  var vm = new Vue({
    el: '#app',
    data: {
      price: 100
    }
  })
  
  // 以下是手写的 render 函数
  function render() {
    with(this){ // this 就是 vm
    return _c(
    	'div',
      {
        attrs: {'id':'app'}
      },
      [
        _c('p', [_v(_s(price))])
      ]
    )
  }
  }
</script>

<!--模板-->
<div id="app">
  <p>{{price}}</p>
</div>
<!-- 模板生成的函数体 -->
<script>
  with(this){
    return _c(
    	'div',
      {
        attrs: {'id':'app'}
      },
      [
        _c('p', [_v(_s(price))])
      ]
    )
  }
</script>
```

- 从哪里可以看到 render 函数？
- 复杂一点的例子，render 函数是什么样子的？
- v-if v-for v-on 都是怎么处理的？

todo-list demo 的 render 函数

> 下载vue源码，搜索 code.render，大概在10679 行
>
> 在其上面找到 var code = generate(ast, options)
>
> alert(code.render)

vue 2.0 开始支持预编译

开发环境：写模板

编译打包：

生成环境：JS 

```html
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
<script>
  with(this){  // this 就是 vm
            return _c(
                'div',
                {
                    attrs:{"id":"app"}
                },
                [
                    _c(
                        'div',
                        [
                            _c(
                                'input',
                                {
                                    directives:[
                                        {
                                            name:"model",
                                            rawName:"v-model",
                                            value:(title),
                                            expression:"title"
                                        }
                                    ],
                                    domProps:{
                                        "value":(title)
                                    },
                                    on:{
                                        "input":function($event){
                                            if($event.target.composing)return;
                                            title=$event.target.value
                                        }
                                    }
                                }
                            ),
                            _v(" "),
                            _c(
                                'button',
                                {
                                    on:{
                                        "click":add
                                    }
                                },
                                [_v("submit")]
                            )
                        ]
                    ),
                    _v(" "),
                    _c('div',
                        [
                            _c(
                                'ul',
                                _l((list),function(item){return _c('li',[_v(_s(item))])})
                            )
                        ]
                    )
                ]
            )
        }
</script>
```

根据 todo-list demo 的 render 函数：

- v-model 是怎么实现的？
- v-on:click 是怎么实现的？
- v-for 是怎么实现的？
- 已经解决了模板中“逻辑”(v-for v-if) 的问题
- 还剩下模板生成 html 的问题
- 另外，vm._c 是什么？render 函数返回了什么？

```js
// 上文中的 render 函数
width(this){
  reutrn _c(
  	'div',
    { attrs: {'id':'app'} },
    [_c('p',[_v(_s(price))])]
  )
}

// 这是学习 snabbdom 时候的 h 函数的写法
var vnode= h('div#container.two.classes', {on: {click: someFn}}, [
  h('span', {style: {fontWeight: 'bold'}}, 'This is bold'),
  'and this is just normal text',
  h('a', {props: {href: '/foo'}}, 'I\'ll take you places!')
])
```

- vm._c 其实就相当于 snbbdom 中的 h 函数
- render 函数执行之后，返回的是 vnode

render 函数和 vdom

- updateComponent 中实现了 vdom 的 patch
- 页面首次渲染执行 updateComponent
- data 中每次修改属性，执行 updateComponent

```js
vm._update(vnode) {
  const prevVnode = vm._vnode
  vm._vnode = vnode
  if (!prevVnode) {
    vm.$el = vm.__patch__(vm.$el, vnode)
  } else {
    vm.$el = vm.__patch__(prevVndoe, vnode)
  }
}
function updateComponent() {
  // vm._render 即 上面的 render 函数，返回 vnode
  vm._update(vm.render())
}
```

**vue 的整个实现流程**

- 第一步：解析模板成 render 函数
- 第二步： 响应式开始监听
- 第三步：首次渲染，显示页面，且绑定依赖
- 第四步：data 属性变化，触发 rerender

todo-list 示例

```html
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
<script type="text/javascript" src="./vue-2.5.1.js"></script> <!-- 直接使用cdn也行-->
<script type="text/javascript">
  var vm = new Vue({
    el: '#app',
    data: {
      title: '',
      list: []
    },
    methods: {
      add: function () {
        this.list.push(this.title)
        this.title = ''
      }
    }
  })
</script>
```

第一步：解析模板成 render 函数

- width 的用法
- 模板中的所有信息都被 render 函数包含
- 模板中用到的 data 中的属性，都变成了 JS 变量
- 模板中的 v-model v-for v-on 都变成了 JS 逻辑
- render 函数返回 vnode

```html
<div id="app">
  <div>
    <input v-model="title">
    <button v-on:click="add">submit</button>
  </div>
  <ul>
    <li v-for="item in list">{{item}}</li>
  </ul>
</div>
```

![1572789845933](./img/vue流程-模板-render函数.png))

第二步：响应式开始监听

- Object.defineProperty
- 将 data 的属性代理到 vm 上

```js
var vm = new Vue({
  el: '#app',
  data: {
    price: 100,
    name: 'zhangsan'
  }
})

var vm = {}
var data = {
  price: 100,
  name: 'zhangsan'
}

var key, value
for(key in value) {
  // 命中闭包。新建一个函数，保证 key 的独立的作用域
  (function (key) {
    Object.defineProperty(vm, key, {
      get: function () {
        console.log('get')
        return data[key]
      },
      set: function (newVal) {
        console.log('set')
        data[key] = newVal
      }
    })
  })(key)
}
```

第三步：首次渲染，显示页面，且绑定依赖

- 初次渲染，执行 updateComponent，执行 vm._render()
- 执行 render 函数， 会访问到 vm.list 和 vm.title
- 会被响应式的 get 方法监听到（后面后详细讲）
- 执行 udpateComponent，会走到 vdom 的 patch 方法
- patch 将 vnode 渲染成 DOM，初次渲染完成

> 为何要监听 get，直接监听 set 不行吗？
>
> - data 中有很多属性，有些被用到，有些可能不被用到
>
> - 被用到的会走到 get，不被用到的不会走到 get
> - 为走到 get 中的属性，set 的时候我们也无需关心
> - 避免不必要的重复渲染

```js
vm._update(vnode) {
  const prevVnode = vm._vnode
  vm._vnode = vnode
  if (!prevVnode) {
    vm.$el = vm.__patch__(vm.$el, vnode)
  } else {
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
}
function updateComponent() {
  // vm._render 即 上面的 render 函数，返回 vnode
  vm._update(vm._render())
}
```

第四步：data 属性变化

- 修改属性，被响应式的 set 监听到
- set 中执行 updateComponent
- updateComponent 重新执行 vm._render()
- 生成的 vnode 和 prevVnode，通过 patch 进行对比
- 渲染到 html 中

```js

Objec.tdefineProperty(vm, key, {
  get: function () {
    console.log('get') // 此处被监听到
    return data[key]
  },
  set: function (newVal) {
    console.log('set')
    data[key] = newVal
  }
})
```



#### 面试题

##### 之前使用jquery和现在使用vue或React框架的区别

- 数据和视图的分离，解耦（开放封闭原则）
- 以数据驱动视图，只关心数据变化，DOM 操作被封装

##### 你如何理解MVVM

- MVVM - Model View ViewModel
- 三者之间的联系，以及如何应对到各段代码
- ViewModel 的理解，联系 View 和 Model

##### vue 如何实现响应式

- 关键是理解 Object.defineProperty
- 将 data 的属性代理到 vm 上

##### vue 如何解析模板

- 模板：字符串，有逻辑，嵌入 JS 变量.....
- 模板必须转换成 JS 代码（有逻辑、渲染 html、JS 变量）
- render 函数是什么样子的
- render 函数执行的是返回 vnode
- updateComponent

##### 介绍 vue 的实现流程

- 第一步：解析模板成 render 函数
- 第二步：响应式开始监听
- 第三步：首次渲染，显示页面，且绑定依赖
- 第四步：data 属性变化，触发 rerender

#### nextTick

涉及到 dom 渲染相关操作时，注意可能需要使用 nextTick

```vue
this.$nextTick(() => {
	// code
})
```

#### vue性能优化

路由懒加载、组件懒加载

懒加载

路由组件的懒加载

```js
// router.js
{
    path: '/goodsList',
    name: 'goodsList',
    // vue-router 懒加载 -> GoodsList
    component: () => import(/* webpackChunkName: "about" */ '../views/GoodsList.vue')
  }
```

组件的懒加载

```vue
// Main.vue
components: {
    ToolBar,
    // 异步组件引入方式, 异步组件：只有在需要去展示这个组件的时候，才会把组件去进行渲染。
    home: () => import('@c/Home'),
    shopping: () => import('@c/Shopping'),
    my: () => import('@c/My')
  },
```

### react

组件化

- 对组件化的理解
- JSX 是什么？
- JSX 和 vdom 什么关系
- 简述React的setState
- 简述自己如何比较React和vue

## 混合开发

- hybrid：基础、和h5对比，上线流程
- 通讯：通讯原理，JS-Bridge 封装
- hybrid是什么，为何要用hybrid
- hybird如何更新上线
- hybrid和h5有何区别
- JS如何与客户端通信

### hybird

- 移动端占大部分流量，已经远远超过 PC
- 一线互联网公司都有自己的 App
- 这些 App 中有很大比例的前端代码

**hybrid是什么，为何要用hybrid**

- hybrid 文字解释
- 存在价值，为何会用 hybrid
- webview
- file::// 协议
- hybrid 实现流程

hybrid 文字解释

- hybrid 即 “混合”，即前端和客户端的混合开发
- 需前端开发人员和客户端开发人员配合完成
- 某些环节也可能涉及到 server 端
- PS：：不要以为前端可以不理会客户端知识

存在价值，为何会用 hybrid

- 可以快速迭代更新（无需 app 审核，因为纯前端代码没有很高的权限）
- 体验流畅（和 NA 的体验基本类似）
- 减少开发和沟通成本法，双端共用一套代码

webview

- 是 app 中的一个组件（app 可以有 webview，也可以没有）
- 用于加载 h5 页面，即一个小型的浏览器内核

file 协议

- http(s)协议 - 加载远程的
- file:// - 这类本地资源的页面
- 区别：file协议，本地文件，快；http(s)协议：网络加载，慢

具体实现

具体实现 - 使用场景

- 不是所有场景都适合使用 hybrid
- 使用NA：体验要求极致，变化不频繁（如头条的首页）
- 使用 hybrid：体验要求高，变化频繁（如头条的新闻详情页）
- 使用 h5：体验无要求，不常用（如举报、反馈等页面）

具体实现

- 前端做好静态页面（html js css），将文件交给客户端
- 客户端拿到前端静态文件，以文件形式存储在 app 中
- 客户端在一个 webview 中
- 使用 file 协议加载静态页面

![1572796632207](./img/hybrid-具体实现.png)

> 遗留问题？
>
> app 发布后，静态文件如何实时更新？
>
> 静态页面如何获取内容？

**hybrid 更新上线流程**

- 回顾 hybrid 实现流程（图）
- 思考（目的，实现途径）
- 更新流程

回顾 hybrid 实现流程（图）

![1572824374028](./img/hybrid-实现流程图.png)

思考（目的，实现途径）

- 要替换每个客户端的静态文件
- 只能客户端来做（客户端是我们开发的）
- 客户端去 server 下载最新的静态文件
- 我们维护 server 的静态文件

完整流程

- 分版本，有版本号，如 201803211015
- 将静态文件压缩成 zip 包，上传到服务端
- 客户端每次启动，都去服务端检查版本号
- 如果服务端版本号大于客户端版本号，就去下载最新的 zip 包
- 下载完之后解压包，然后将现有文件覆盖

![1572824699619](./img/hybrid-完整流程.png)

### hybird vs H5

- 优点
- 缺点
- 适用的场景

优点

- 体验更好，跟 NA 体验基本一致
- 可快速迭代，无序 app 审核（关键）

缺点

- 开发成本高。联调、测试、查 bug 都比比较麻烦
- 运维成本高。参考此前讲过的更新上线的流程

适用的场景

- hybrid：产品的稳定功能，体验要求高，迭代频繁
- h5：单次的运营活动（如 xx 红包）

### 前端客户端通讯

- 回顾之前遗留的问题
- JS 和客户端通讯的基本形式
- schema 协议简介和使用
- schema 使用的封装
- 内置上线

**之前遗留的问题**

- 新闻详情页适用 hybrid，前端如何获取新闻内容？
- 不能用 ajax 获取。第一 跨域，第二 速度慢
- 客户端获取新闻内容，然后 JS 通讯拿到内容，再渲染

**JS 和客户端通讯的基本形式**

- JS 访问客户端能力，传递参数和回调函数
- 客户端通过回调函数返回内容

![1572828159241](./img/hybrid-js和客户端通讯形式.png)

**schema 协议简介和使用**

- 之前介绍了 http(s) 和 file 协议
- schema 协议 —— 前端和客户端通讯的约定

![1572828411977](./img/hybrid-schema协议-微信案例.png)

```js
/* 以下是演示，无法正常运行，微信有严格的权限验证，外部页面不能随意使用 schema */
// 调用 扫一扫
var iframe = document.createElement('iframe')
iframe.style.display = 'none'
iframe.src = 'weixin://dl/scan' // iframe 访问 schema 重要！
var body = document.body ||| document.getElementsByTagName('body')[0]
body.appendChild(iframe)
setTimeout(function () {
  body.removeChild(iframe) // 销毁 iframe
  iframe = null
})
```

```js
/* 如果要加上参数和 callback，那么就要这么写 */
window['_weixin_scan_callback'] = function (result) {
  alert(result)
}
// ...省略...
iframe.src='weixin://dl/scan?k1=v1&k2=v2&=k3=v3&callback=_weixin_scan_callback'
// ...省略...
```

**schema 使用的封装**

```js
// 最终使用形式
window.invoke.share({title: 'xxx', content: 'xxx'}, function (result) {
  if (result.errno === 0) {
    alert('分享成功')
  } else {
    alert(result.message)
  }
})

function invokeShare(data, callback) {
  _invoke('share', data, callback)
}

function invokeLogin(data, callback) {
  _invoke('login', data, callback)
}

function invokeScan(data, callback) {
  _invoke('scan', data, callback)
}
// 暴露到全局变量
window.invoke = {
  share: invokeShare,
  login: invokeLogin,
  scanZ: invokeScan
}
// 调用 schema 的封装
function _invoke(action, data, callback) {
  // 拼接 schema 协议
  var schema = 'myapp://utils'
  schema += '/' + action
  //拼接参数
  schema += '?a=a'
  var key
  for (key in data) {
    if (data.hasOwnProperty(key)) {
      schema += '&' + key + '=' + data[key]
    }
  }
  // 处理 callback
  var callbackName = ''
  if (typeof callback === 'string') {
    callbackName = callback
  } else {
    callbackName = action + Date.now()
    window[callbackName] = callback
  }
  
  schema += '&callback=' + callbackName
  
  // 触发 iframe 中调用 schema
  var iframe = document.createElement('iframe')
  iframe.style.display = 'none'
  iframe.src = schema // 重要！
  var body = document.body ||| document.getElementsByTagName('body')[0]
  body.appendChild(iframe)
  setTimeout(function () {
    body.removeChild(iframe) // 销毁 iframe
    iframe = null
  })
  
}
```

**内置上线**

- 将以上封装的代码打包，叫做 invoke.js，内置到客户端
- 客户端每次启动 webview，都默认执行 invoke.js
- 本地加载，免去网络加载的时间，更快
- 本地加载，没有网络请求，黑客看不到 schema 协议，更安全

### 面试题

#### hybrid 是什么，为何用 hybrid？

- hybrid 是客户端和前端的混合开发
- hybrid 存在的核心意义在于快速迭代，无需审核
- hybrid 实现流程（图），以及 webview 和 file 协议

#### 介绍一下 hybrid 更新和上线的流程？

- 掌握流程图
- 要点1：服务端的版本和 zip 包维护
- 要点2：更新 zi 包之前，先对比版本号
- 要点3：zip 下载解压和覆盖

#### hybrid 和 h5 的主要区别

- 优点：体验好，可快速迭代
- 缺点：开发成本高，运维成本高
- 适用的场景：hybrid 适合产品型，h5使用运营型

#### 前端 JS 和客户端如何通讯？

- 通讯的基本形式：调用能力，传递参数，监听回调
- 对 schema 协议的理解和使用
- 调用 schema 代码的封装
- 内置上线的好处：更快、更安全

## 业务相关

### 瀑布流

瀑布流的布局：

​      1、创建商品列表的基本html 和 css ， 让 item 相对于 goods（div）进行排列(相对布局)

​      2、生成不同高度的图片，撑起不同高度的 item。

​      3、计算 item 的位置，来达到 从上到下，从左到右依次排列的目的

## 面试技巧

- 简历
  - 简介明了，重点突出项目经历和解决方案
  - 把个人博客放在简历中，并且定期维护更新博客
  - 把个人的开源项目放在简历中，并维护开源项目
- 面试过程中
  - 如何看待加班？加班就像借钱，救急不救穷
  - 不要挑战面试官，不要反考面试官
  - 学会给面试官惊喜，但不要太多
  - 遇到不会的，说出知道的
  - 说说缺点———说一下你最近正在学什么就可以了

## 手写题

### 防抖 & 节流

原理都是利用闭包保存变量。防抖是任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行，一般用于输入框实时搜索；节流是规定函数在指定的时间间隔内只执行一次，一般用于scroll事件。

```js
// 防抖
function debounce(fn,time){
    let timer = null;
    return function(){
        if(timer){
            clearTimeout(timer)
        }
        timer = setTimeout(()=>{
            fn.apply(this,arguments)
        },time)
    }
}
// 节流
function throttle(fn,time){
    let canRun = true;
    return function(){
        if(!canRun){
            return
        }
        canRun = false;
        setTimeout(() => {
            fn.apply(this,arguments);
            canRun = true;
        },time)
    }
}
```

### 深拷贝

要考察的是递归、数组和对象的存储。

```js
function deepClone(obj) {
  var result = Array.isArray(obj) ? [] : {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (typeof obj[key] === 'object' && obj[key]!==null) {
        result[key] = deepClone(obj[key]); 
      } else {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

function deepClone(arr){
    return JSON.parse(JSON.stringify(arr))
}
```

### 数组乱序

```js
// 著名的Fisher–Yates shuffle 洗牌算法
function shuffle(arr){
    let m = arr.length;
    while(m > 1){
        let index = parseInt(Math.random() * m--);
        [arr[index],arr[m]] = [arr[m],arr[index]];
    }
    return arr;
}
```

### 数组去重

```js
// 1
function removeDup(arr){
    var result = [];
    var hashMap = {};
    for(var i = 0; i < arr.length; i++){
        var temp = arr[i]
        if(!hashMap[temp]){
            hashMap[temp] = true
            result.push(temp)
        }
    }
    return result;
}
// 2
Array.from(new Set(arr))
// 3
[...new Set(arr)]
// 4 
function unique(arr) {
  var result = []
  arr.forEach(item => {
    if (result.indexOf(item) < 0) {
      result.push(item)
    }
  })
  return result
}
// 5
function unique(arr) {
  var result = []
  var hash = {}
  arr.forEach(item => {
    if (!hash[item]) {
      hash[item] = true
      result.push(item)
    }
  })
  return result
}
```

### 数组 flat

```js
// 展平一级
function flat(arr){
    var result = [];
    for(var i = 0; i < arr.length; i++){
        if(Array.isArray(arr[i])){
            result = result.concat(flat(arr[i]))
        }else{
            result.push(arr[i]);
        }
    }
    return result;
}

//展平多层
 function flattenByDeep(array,deep){
      var result = [];
      for(var i = 0 ; i < array.length; i++){
          if(Array.isArray(array[i]) && deep >= 1){
                result = result.concat(flattenByDeep(array[i],deep -1))
          }else{
                result.push(array[i])
          }
      }
      return result;
  }
```

### filter

```js
Array.prototype.filter = function(fn,context){
    if(typeof fn != 'function'){
        throw new TypeError(`${fn} is not a function`)
    }
    let arr = this;
    let reuslt = []
    for(var i = 0;i < arr.length; i++){
        let temp= fn.call(context,arr[i],i,arr);
        if(temp){
            result.push(arr[i]);
        }
    }
    return result
}
```

### 手写call & apply & bind

```js
Function.prototype.myCall = function(context){ 
    if(typeof this != 'function'){
        throw new TypeError('this is not a function')
    }
    context.fn = this;
    var arr = [];
    for(var i = 1; i< arguments.length; i++){
        arr.push('argument[' + i + ']')
    }
    var result = eval('context.fn(' +arr+ ')');
    delete context.fn;
    return result;
}

Function.prototype.myApply = function(context,arr){ 
    if(typeof this != 'function'){
        throw new TypeError('this is not a function')
    }
    context.fn = this;
    var result= [];
    if(!arr){
        result = context.fn()
    }else{
        var args = [];
        for(var i = 1; i< arr.length; i++){
            args.push('arr[' + i + ']')
        }
        result = eval('context.fn(' +args+ ')');
    }
    delete context.fn;
    return result;
}

Function.prototype.myBind = function(context){
    if(typeof this != 'function'){
        throw new TypeError('this is not a function')
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments,1);
    var F = function(){};
    F.prototype = this.prototype;
    var bound = function(){
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof F ? this: context, args.concat(bindArgs))
    };
    bound.prototype = new F();
    return bound;
}

```

bind

```js
Function.prototype.bind = function(context) {
    const self = this
    const args = [...arguments].slice(1)
    return function F() {
        if (self instanceof F) {
            return new self(...args, ...arguments)
        }
        return self.apply(context, args.concat(...arguments))
    }
}
```



### 函数currying

函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术，是高阶函数的一种用法。比如求和函数`add(1,2,3)`, 经过柯里化后变成`add(1)(2)(3)`

```js
function currying(fn,...args){
    if(fn.length <= args.length){
        return fn(...args)
    }
    return function(...args1){
        return currying(fn,...args,...args1)
    }
}
function add(a,b,c){
    return a + b + c
}
add(1,2,3) // 6
var curryingAdd = currying(add);
curryingAdd(1)(2)(3) // 6
```

### 实现eventEmitter

观察者模式是我们工作中经常能接触到的一种设计模式。用过 `jquery` 的应该对这种设计模式都不陌生。`eventEmitter` 是 `node` 中的核心，主要方法包括`on、emit、off、once`。

```js
class EventEmitter {
    constructor(){
        this.events = {}
    }
    on(name,cb){
        if(!this.events[name]){
            this.events[name] = [cb];
        }else{
            this.events[name].push(cb)
        }
    }
    emit(name,...arg){
        if(this.events[name]){
            this.events[name].forEach(fn => {
                fn.call(this,...arg)
            })
        }
    }
    off(name,cb){
        if(this.events[name]){
            this.events[name] = this.events[name].filter(fn => {
                return fn != cb
            })
        }
    }
    once(name,fn){
        var onlyOnce = () => {
            fn.apply(this,arguments);
            this.off(name,onlyOnce)
        }
        this.on(name,onlyOnce);
        return this;
    }
}

```

### 快排

```js
function quickSort(arr) {
  if (arr.legnth <=1) return arr
  var index = Math.floor(arr.length / 2)
  var standard = arr.splice(index, 1)[0]
  var left = [], right =[]
  arr.forEach(item => {
    item <= standard ? left.push(item) : right.push(item)
  })
  return quickSort(left).concat([standard, quickSort(right)])
}
```

### 实现斐波那契算法

```js
function fibonacci(n){
  if (n < 0) return 0
  if (n < 2) return 1
  return fibonacci(n -1) + fibonacci(n - 2)
}
```



