# 小程序进阶-临时

## appkey获取

github 关键词 旧岛

```json
const config = {
  api_blink_url: 'http://bl.7yue.pro/v1/',
  appkey: 'RdshydjBvcYZhMZC'
}
```

## 第六章

###  数据来源的三种途径

- WXML
- JS->WXML
- 服务器->JS-WXML

### 数据绑定

js 中，data 中存数据；WXML 中，通过 {{}} 绑定数据

### 三元表达式与图片切换

通过三元表达式控制图片或数据的切换

```html
// wxml
<image src="{{like?yesSrc : noSrc}}"  />
<text>{{like?count1:count2}}</text>
```

```js
// js
data: {
    like: true,
    count1: 99,
    count2: 999,
    yesSrc: 'images/like.png',
    noSrc: 'images/like2.png'
}
```

### 组件的封闭性，开放性及粒度

开放性：可以从组件外部进行设置，也就是通过  properties

### 组件的properties属性详解

```html
// wxml
<image src="{{like?yesSrc : noSrc}}"  />
<text>{{like?count1:count2}}</text>
```

```js
// js
Component({
    properties: {
        like:{
            type: Boolean
        },
        count:{
            type: Number
        }
    },
    data: {
        like: true,
        count1: 99,
        count2: 999,
        yesSrc: 'images/like.png',
        noSrc: 'images/like2.png'
    }
})
```

### let,var与组件事件应用

## 第七章

### 看待组件的两种观点

组件的好处：复用、代码分离

代码分离>复用

### 生命周期函数

### wx.request-4xx状态码并不会执行fail

### 合法域名问题

开发阶段可以不校验合法域名，但是上线后必须在小程序后台添加合法域名

### 访问API获取数据

```js
onLoad: function (options) {
    wx.request({
        url：'',
        header: {
        	appkey: ''
    	}
    })
}
```

开发阶段应该对上述请求函数进行封装，直接写是不可取的。

### 正确理解 Promise

应用场景：

- 解决异步嵌套的问题-回调地狱
- 利用 return

### 模块化导入公共配置文件

根目录新建 config.js 文件

存储公共数据，并使用 `export` 导出

```js
export const config = {
    api_base_url: 'http://bl.7yue.pro/v1/',
    appkey: "RdshydjBvcYZhMZC"
}
```

使用 ES Module export 与 import 导入公共数据

新建 util/http.js，定义一个 http 类，封装 request 请求方法，公共配置数据通过 `import `引入

```js
import {config} from '/config.js'
class HTTP {
    request (params) {
        // url, data, method
        wx.request({
            url
        })
    }
}
```

**导出多个数据与引入多个数据**

**导出**

```js
// config.js
export const config = {}
export let fn1 = function () {}
```

或

```js
// config.js
const config = {}
let fn1 = function () {}

export {conifg, fn1}
```

导出时，改名字

```js
export {config as config1}
```



**引入**

```js
import {config, fn1} from '/config.js'
```

引入时，改名字

```js
import {config as config1, fn1} from '/config.js'
```

### HTTP类的封装与ES6 startsWith

```js
import {config} from '/config.js'

class HTTP {
    request (params) {
        // url, data, method
        if (!params.method) {
            params.method = "GET"
        }
        wx.request({
            url: config.api_base_url + params.url,
            method: params.method,
            data:params.data,
            header: {
                'content-type':'application/json',
                'appkey': config.appkey
            },
            success: (res) => {
                let code = res.statusCode.toString()
                // 拿到字符串的首字母
                // var startChar = code.charAt(0)
                // if (startChar == '2') {}
                if (code.startsWith('2')) {
                    // 回调函数传递
                    params.success(res.data)
                } else {
                    // 服务器异常
                }
            },
            fail: (err) => {
                // api 调用失败
            }
        })
    }
}

export {HTTP}
```

注意：导出和引入只能使用相对路径

### 通用错误异常处理

好的反馈

![好的反馈](./img/好的反馈.png)

```js
import {config} from '../config.js'

// request 函数代码已经很多，应该在进行拆分
const tip = {
    1： '抱歉，出现了一个错误',
    1005: 'appkey无效，请前往www.7yue.pro申请',
    3000: '期刊不存在'
}

class HTTP {
    request (params) {
        if (!params.method) {
            params.method = "GET"
        }
        wx.request({
            url: config.api_base_url + params.url,
            method: params.method,
            data:params.data,
            header: {
                'content-type':'application/json',
                'appkey': config.appkey
            },
            success: (res) => {
                let code = res.statusCode.toString()
                if (code.startsWith('2')) {
                    // 回调函数传递
                    params.success(res.data)
                } else {
                    // 服务器异常
                    // 根据文档，模拟 4xx 的错误情况
                    let error_code = res.data.error_code
                    this._show_error(error_code)
                }
            },
            fail: (err) => {
                // api 调用失败
                // 断网后，可看到效果
                this._show_error(1)
            }
        })   
    }
    
    // es6 没有提供私有函数的标准，这里通过下划线表示私有函数，只在函数内调用（自定义的私有函数可以再外部调用，不过不要这样做）
    _show_error (error_code) {
        if (!error_code) {
            error_code = 1
        }
        wx.showToast({
            title: tips[error_code],
            icon: 'none',
            duration: 2000
        })
    }
}

export {HTTP}
```

页面使用

比直接在页面写代码少很多，但这还不是最好的写法。

```js
import {HTTP} from '../../utils/http.js'

let http = new HTTP()

Page({
  onLoad: function (options) {
    http.request({
      url: 'classic/latest',
      success: (res) => {
        console.log(res)
      }
    })
  }
})
```

## 第八章

### 什么是'剥夺函数 return 的能力'

使用回调函数剥夺了函数 return 的能力

### 组件属性赋值与页面渲染流程解析

![api数据传入组件](./img/api数据传入组件.png)

### setData 的误区

误区1：只有通过setData 设置的数据才能被 wxml 使用，这是错误的。

反例：如果 data 中有数据，是可以在 wxml 中显示数据的。

```js
data: {
    test: 1
}
```

对于页面或组件的 wxml，所能使用的数据完全取决于 data 中有什么数据，setData 用于数据更新(更新数据必须通过 setData，直接赋值操作无效)。

```js
// 无效
this.data.test =2
// 只能通过setData
this.setData({
    test: 2
})
```

若 data 中没有 setData 更新的数据项，setData 会先创建这个数据项然后再更新。凡是要被 wxml 使用的变量最好都在 data 中标识，如像异步操作更新的数据最好还是在 data 中设置默认值，否则数据没有请求回来前，页面无法正常显示。

### movie组件的实现

**vscode格式化css代码**：安装 Beautify 插件

css技术点

**不规则调整图片的位置**

```css
.tag {
  width: 46rpx;
  height: 142rpx;
}
/* 通过 relative 调整 */ 
.tag {
  width: 46rpx;
  height: 142rpx;
  position: relative;
  right: 310rpx;
  bottom: 58rpx;
}
```

**让文字换行并居中**

在整体居中的条件下，设置最大宽度 ` max-width: 550rpx;`，这样即使文字少也是会居中的

### 再谈组件的实现

组件的通用性

例如 http 请求这种业务性代码也该写在使用方，而就是 paga 页面中，而不应该写在组件中

### 自定义事件的激活与监听

通过 tap 事件不能把组件的数据传入页面，这时，需要用到自定义事件

通过 triggerEvent 自定义 like 事件，并通过第二个参数对象传参

```js
// like 组件内
methods: {
    onLike: function(event) {
      // 自定义事件
      // 激活
      let behavior = this.properties.like ? 'like' : 'cancel'
      this.triggerEvent('like', {
        behavior: behavior // 通过第二个参数对象进行传参
      }, {})
    }
  }
```
在页面中，监听 like 事件，并通过 event.detail 拿到数据
```html
<--页面内-->
    <v-like  bind:like="onLike" like="{{classic.like_status}}" count="{{classic.fav_nums}}"/>
```

```js
 onLike: function (event) {
    let behavior = event.detail.behavior
  },
```

### 喜欢还是不喜欢

判断是否存在，执行操作写法**

利用 && 短路操作，如果存在就执行，不存在就不执行

```js
// 利用 && 判断是否传入了 success 回调函数
params.success && params.success(res.data)
```

### 组件的生命周期

文档-框架-自定义组件-Component构造器

5个组件生命周期函数

### 组件的data与properties的奇怪现象

第一，可以看到在 properties 中可以使用 Number 或 String 当作默认值，而在data中**不可以**。

第二，properties 和 data 中的属性是一样的。所以微信会把 properties 和 data 合并成同一个 js 对象，当我们访问任意一个时，都指向同一个 js 对象。**注意**：properties 和 data 中不要出现同名属性，小程序合并时会覆盖掉。

```js
// 组件 js
Component({
  properties: {
    index: Number
  },
  data: {
    year: Number,
    month: String
  },

  attached: function(){
    console.log(this.properties) // {index: 0, year: ƒ, month: ƒ}
    console.log(this.data)       // {index: 0, year: ƒ, month: ƒ}
  }
})
```

所有 data 中的属性默认值设置可以是：

```js
data: {
    year: 0,
    month: ""
}
```

### 业务逻辑到底写组件里还是页面里

例如组件某个数据需要补零操作

- 我可以page页面中拿到数据后进行补零操作，再传入到组件
- 将原始数据传入组件，在组件内部进行补零操作（正确）

分析：这个数据只有组件用到，所以补零操作是归属于组件的，应该在组件内部进行处理。

封装组件不是最难的，关键是判断业务逻辑是写在组件内还是组件外，达到组件的灵活性、应用型和方便性。

### observer 函数的应用

监听传入组件的某个值，当值发生变化时，执行 observer 函数

### 千万不要在observer中修改自身属性

**微信的去零操作**

```js
 properties: {
    index: {
      type: Number,
      observer: function (newVal, oldVal, changedPath) {
        let val = newVal < 10 ? '0' + newVal : newVal
        this.setData({
          index: '08' // type 类型是 Number，微信会自动把 08 转成 8，达不到补零操作
        })
      }
    }
  },
  data: {
    year: Number,
    month: String
  },
```

**oberver 和 setData 引发的内存泄漏**

若在 observer 中 setData 的属性名和监听的属性名相同，有可能会引发无线循环，从而导致**内存泄漏**，如下的补零操作：监听 type 值，当 type 改变时调用 observer函数，补零，setData index ，index 发生变化，重复上述操作，导致无线循环，内存泄漏。

````js
 properties: {
    index: {
      type: String, // 这里改成字符串，防止微信的去零操作
      observer: function (newVal, oldVal, changedPath) {
        let val = newVal < 10 ? '0' + newVal : newVal
        this.setData({
          index: val
        })
      }
    }
  },
  data: {
    year: Number,
    month: String
  },
````

**通过新的属性保存改变后的值，避免oberver setData 发生内存泄漏**

```js
 properties: {
    index: {
      type: String,
      observer: function (newVal, oldVal, changedPath) {
        let val = newVal < 10 ? '0' + newVal : newVal
        this.setData({
          _index: val // 利用 _index 保存修改后得的值
        })
      }
    }
  },
  data: {
    year: Number,
    month: String,
    _index: ''
  },
```

通过 oberserver 进行补零操作不是最好的方案，**wxs**才是。

### epsoide组件与流行页面样式

**月份变汉字**

```js
let months = ['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月']
let date = new Date()
let month = date.getMonth()

// 将 month 作为索引读取对应文字描述
let result = months[month]
```

**文字基线对齐**

```css
.index-container{
  display:flex;
  flex-direction: row;
  align-items: baseline;      
}
```

## 第九章

### navi组件与移动端触碰区域讨论

不同于pc鼠标的精确点击，手机触碰区域要更大一些，对单指操作用户体验提升很大。

- 可以让设计师加图片设计的大一些。
- 或者通过代码是触碰区域大一些。

### navi组件与flex宽度陷阱

如果确定要撑满屏幕，最后加上 width: 100%;不然有时候会撑不满

### 禁用事件的技巧

**如何在真机上进行调试**

点击预览，生成二维码，手机微信扫描二维码，点击三个点，点击进入调试，重新扫描二维码即可。

**事件机制**

当我们在嵌套组件的最底层组件创建一个自定义事件，事件是可以一直冒泡到 Page 的。

![组件自定义事件机制](./img/组件自定义事件机制.png)

具体组件出发自定义事件，及页面监听事件

```html
组件内 
<image bind:tap="onLeft" class="icon" src="{{latest?disLeftSrc:leftSrc}}" />
```

```js

methods: {
    onLeft: function (event) {
        this.tirggerEvent('left', {}, {})
    }
}
```

```html
页面内
<v-navi bind:left="onNext"/>
```

**禁止事件的技巧**

在组件内部判断是否是第一期或是最新一期，来决定是否触发事件。

```js
methods: {
    onLeft: function (event) {
        if (!this.properties.latest) {
            this.tirggerEvent('left', {}, {})
        }
    },
    onRight: function (event) {
        if (!this.properties.first) {
            this.tirggerEvent('left', {}, {})        
        }
    }
  }
```

### music 组件初步实现

三种类型的期刊：电影、音乐、句子。所以需再封装音乐组件和句子组件。

由于音乐组件比较复杂，所以先实现基本的页面

### 初识组件的behavior行为

句子组件，同样不要开始做的多复杂，只需要能显示句子即可。

在面向对象编程中，是通过 class 继承的。在小程序中，组件代码继承是通过 behaviors 继承的。

Behavior 是一个构造器,一个组件可以继承多个 behavior。



创建 class-beh.js 文件，通过 Behavior 构造器，存放公共代码部分

```js
// class-beh.js
let classicBeh = Behavior({
    properties: {
        img: String,
        content: String
    },
    attached: function () {

    },
    data: {},
    method: {}
})

export {classicBeh}
```

在组件中引入后，通过`behaviors`选项使用

```js
import {classicBeh} from '../class-beh.js'

Component({
  behaviors: [classicBeh], // 可以引入多个 behavior
  properties: {}
})
```

### behavior继承与多继承的覆盖规则

behavior 优势在于都多个项目，其思维还是面向对象继承的思想。Python是多继承，其他语言是单继承。而 behavior 也是一种多继承思想。

es6 的 class extends 就是单继承

**behavior 多继承 变量同名覆盖的问题**

小程序的规则如下：

- 当组件 properties 属性和 behavior 中的重名时，组件的 properties  属性会覆盖 hehavior 的，符合面向对象继承的规则，子类会覆盖父类中的相关属性。
- 若子组件中properties 没有属性值，3个beh中都有相同的属性时，后面的会覆盖前面的

规则同样适用于 methods 的继承

特例：生命周期函数的继承。

- 若 beh 和子组件都有相同的生命周期函数，小程序会依次调用behs中的生命周期函数，最后调用子组件的生命周期函数，而不是覆盖。

```js
// 其中一个 behavior
let classicBeh = Behavior({
    properties: {
        img: String,
        content: String
    },
    attached: function () {

    },
    data: {},
    method: {}
})

export {classicBeh}
```

```js
// 组件中
Component({
    behaviors: [beh1, beh2, beh3],
    properties: {
        img: Number
    }
})
```

### 是否是最新期刊的逻辑判断初步实现期刊切换

所有对 classic 的相关操作，都会集中在 classicModel 这个类当中。

### 使用Storage保存最新期刊号

封装小函数，可读性更强，起到了注释的作用

通过把具体逻辑封装到 model 中，我们不需要把具体的逻辑写在页面中。

**使用缓存可能会引起一些问题**

如果在写入缓存不够小心写入一些错误的数据，在读取时就会出错，而缓存不会随着程序关闭而清除，这时需要手动清除缓存。

**清缓存**：小程序开发工具-清缓存，选择清除数据缓存。	

### onNext与函数重构技巧

一些问题，数据都是实时请求的，但要提高网页性能和用户体验就需要用到缓存。

## 第10章 新版Music组件、组件通信与wxss样式复用

### 谈谈缓存对于改善用户体验的作用

缓存思路：检查有无缓存，若无，请求 API 写入缓存

###  解决缓存带来的问题

思考那些数据可以被缓存，那些数据不应该被缓存，例如一些固定不变的数据是可以用缓存的，而经常由于其他因素导致的变化是不应该用缓存的，例如点赞的人数和状态。

### ES6模板字符串和扩展运算符的应用

对象扩展运算符使用要灵活一些，如果需要将数据封装或说明，不使用扩展运算符反而更好些。

### 独立更新like组件状态

